<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Empire</title>

  <style>
    html, body { height:100%; margin:0; background:#0f1220; overflow:hidden; }

    canvas{
      position:fixed; inset:0; width:100%; height:100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action:none;      /* pointer gestures on canvas */
      display:block;
    }

    /* UI overlay clipped to visible map rect */
    #uiOverlay{
      position:fixed;
      left:0; top:0;
      width:0; height:0;
      overflow:hidden;
      pointer-events:none; /* default pass-through; panels re-enable */
      z-index:1000;
    }

    #resourceBar{
      position:absolute;
      left:0; top:0; right:0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;

      padding:12px 14px;
      background:linear-gradient(180deg, rgba(10,14,30,.92), rgba(0,0,0,.55));
      color:#eaf0ff;
      font:14px/1.15 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      border-bottom:1px solid rgba(255,255,255,.12);

      pointer-events:auto;
      user-select:none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);

      box-shadow:
        0 10px 30px rgba(0,0,0,.35),
        inset 0 -1px 0 rgba(255,255,255,.06);
      touch-action: manipulation;
    }

    #resourceLeft{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
    }

    .resItem{
      display:flex;
      gap:8px;
      align-items:baseline;
      padding:6px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      white-space:nowrap;
    }

    .resItem b{ font-weight:900; letter-spacing:.2px; }
    .resItem span{ opacity:.8; font-size:12px; margin-left:2px; }

    #resourceRight{ display:flex; gap:10px; align-items:center; }

    #resourceRight button{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      color:#eaf0ff;
      cursor:pointer;
      font:13px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      touch-action: manipulation;
    }

    #resourceRight button:hover{
      background:rgba(255,255,255,.14);
      border-color:rgba(255,255,255,.22);
      transform: translateY(-1px);
    }
    #resourceRight button:active{ transform: translateY(0px); }

    #floatingPanels{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    .uiPanel{
      position:absolute;
      min-width:280px;
      max-width:420px;
      background:rgba(0,0,0,.78);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      pointer-events:auto;
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      touch-action: manipulation;
    }
    .uiPanel, .uiPanel * { pointer-events:auto; }
    .uiPanel button, .uiPanel select, .uiPanel input { touch-action: manipulation; }

    /* Build popup */
    #buildPopup{ display:none; }
    #buildTitle{ font-weight:900; margin-bottom:10px; font-size:14px; }
    #buildGrid{ display:block; }
    .buildBtn{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      text-align:left;
      white-space:pre-line;
      transition: background 120ms ease, transform 120ms ease;
      width:100%;
      touch-action: manipulation;
    }
    .buildBtn:hover{ background:rgba(255,255,255,.16); transform: translateY(-1px); }
    .buildBtn:active{ transform: translateY(0px); }

    .row{ display:flex; justify-content:flex-end; gap:10px; margin-top:12px; }
    .closeBtn{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      touch-action: manipulation;
    }
    .closeBtn:hover{ background:rgba(255,255,255,.16); }

    /* Barracks */
    #barracksPanel{ display:none; width:420px; max-height:70vh; overflow:auto; }

    /* Upgrade card */
    .upCard{
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 14px;
      color: #e5e7eb;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
    }

    .upTitle{
      font-size: 18px;
      font-weight: 900;
      letter-spacing: .2px;
      margin-bottom: 8px;
      color:#ffffff;
    }

    .upRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size: 14px;
      margin: 6px 0;
      opacity: .95;
    }
    .upRow b{ font-weight: 900; }
    .upCost{ font-weight: 900; letter-spacing: .3px; }

    .upHint{
      margin-top: 10px;
      font-size: 12px;
      opacity: .78;
      line-height: 1.3;
    }

    .upBtn{
      margin-top: 12px;
      width: 100%;
      border: 0;
      border-radius: 14px;
      padding: 14px 14px;
      font-weight: 900;
      font-size: 16px;
      cursor: pointer;
      background: #22c55e;
      color: #06210f;
      box-shadow: 0 12px 26px rgba(34,197,94,.25);
      touch-action: manipulation;
    }

    .upBtn:hover{ filter: brightness(1.05); }
    .upBtn:active{ transform: translateY(1px); }

    .upBtn[disabled]{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.45);
      box-shadow: none;
      cursor: not-allowed;
    }

    .upReason{
      margin-top: 10px;
      font-size: 12px;
      opacity: .85;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
    }

    /* Barracks tabs */
    .bxHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
    .bxClose{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      touch-action: manipulation;
    }
    .bxClose:hover{ background:rgba(255,255,255,.16); }
    .bxWrap{ display:flex; gap:12px; }
    .bxTabs{
      width:120px;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-right:10px;
      border-right:1px solid rgba(255,255,255,.10);
    }
    .bxTab{
      width:100%;
      text-align:left;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      cursor:pointer;
      font-weight:900;
      touch-action: manipulation;
    }
    .bxTab:hover{ background:rgba(255,255,255,.10); }
    .bxTab.active{
      background:rgba(34,197,94,.18);
      border-color:rgba(34,197,94,.35);
      color:#eafff2;
    }
    .bxMain{ flex:1; min-width:0; }
  </style>

  <link rel="icon" href="./favicon.ico">
</head>

<body>
  <canvas id="cityCanvas"></canvas>

  <div id="uiOverlay">
    <div id="resourceBar">
      <div id="resourceLeft"></div>
      <div id="resourceRight">
        <button id="btnSave" type="button">Save</button>
        <button id="btnLoad" type="button">Load</button>
        <button id="btnReset" type="button">Reset</button>
      </div>
    </div>

    <div id="floatingPanels">
      <div id="buildPopup" class="uiPanel">
        <div id="buildTitle">Build</div>
        <div id="buildGrid"></div>
        <div class="row">
          <button id="buildClose" class="closeBtn" type="button" data-action="build-close">Close</button>
        </div>
      </div>

      <div id="barracksPanel" class="uiPanel"></div>
    </div>
  </div>

  <script type="module">
    // =========================================================
    // 1) IMPORTS
    // =========================================================
    import { CITY_PLOTS } from "./js/plots.city.js";
    import { BUILDINGS } from "./js/data/buildingCatalog.js";
    import { createcitybuildingsSystem } from "./js/systems/cityBuildings.js";
    import { state } from "./js/state.js";
    import { updateEconomy, getProductionPerSecond } from "./js/systems/cityEconomy.js";
    import { processTrainingQueues } from "./js/systems/trainingsystems.js";
    import { getTrainingSnapshot, startTrainingInSlot, cancelTraining, syncBarracksSlots } from "./js/systems/trainingsystems.js";
    import { TROOPS, BARRACKS_TIER_UNLOCK } from "./js/data/troopsCatalog.js";

    // =========================================================
    // 2) CONSTANTS
    // =========================================================
    const BASE_MAP_SRC = "./assets/maps/city/city_tilemap_base.png";
    const BUILDING_BASE_PATH = "./assets/city";
    const SAVE_KEY = "empire_city_save_v1";
    const PENDING_KEY = "EMPIRE_PENDING_LOAD";

    // =========================================================
    // 3) PURE POINTER EVENTS CANVAS SCENE (NO touch* listeners)
    // =========================================================
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function createCityScene(canvas, { baseMapSrc }) {
      const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });
      ctx.imageSmoothingEnabled = false;

      let buildingsSystem = null;
      let onPlotClick = null;

      let baseImg = null;
      let baseW = 512, baseH = 512;

      const cam = {
        x: baseW/2,
        y: baseH/2,
        zoom: 2,
        minZoom: 1,
        maxZoom: 6
      };

      const sceneState = {
        plots: [],
        selectedPlotId: null,
      };

      function resizeCanvas(){
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const r = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(r.width * dpr));
        const h = Math.max(1, Math.floor(r.height * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
          ctx.setTransform(1,0,0,1,0,0);
          ctx.imageSmoothingEnabled = false;
        }
      }

      function worldToScreen(wx, wy){
        const cx = canvas.width/2, cy = canvas.height/2;
        return { x:(wx-cam.x)*cam.zoom+cx, y:(wy-cam.y)*cam.zoom+cy };
      }

      function screenToWorld(sx, sy){
        const cx = canvas.width/2, cy = canvas.height/2;
        return { x:(sx-cx)/cam.zoom+cam.x, y:(sy-cy)/cam.zoom+cam.y };
      }

      function clampCameraToMap(){
        const viewW = canvas.width / cam.zoom;
        const viewH = canvas.height / cam.zoom;

        if (viewW >= baseW) cam.x = baseW / 2;
        else {
          const half = viewW / 2;
          cam.x = clamp(cam.x, half, baseW - half);
        }

        if (viewH >= baseH) cam.y = baseH / 2;
        else {
          const half = viewH / 2;
          cam.y = clamp(cam.y, half, baseH - half);
        }
      }

      function computeMinZoomToFit(){
        const zX = canvas.width / baseW;
        const zY = canvas.height / baseH;
        return Math.max(zX, zY);
      }

      function zoomAt(delta, sx, sy){
        const before = screenToWorld(sx, sy);
        cam.minZoom = computeMinZoomToFit();
        cam.zoom = clamp(cam.zoom * delta, cam.minZoom, cam.maxZoom);
        const after = screenToWorld(sx, sy);
        cam.x += (before.x - after.x);
        cam.y += (before.y - after.y);
        clampCameraToMap();
      }

      function eventToCanvasXY(e){
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top)  * (canvas.height / rect.height);
        return { x, y };
      }

      function pointInRect(px, py, r){
        return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
      }

      function pickPlot(wx, wy){
        for (let i = sceneState.plots.length - 1; i >= 0; i--) {
          const p = sceneState.plots[i];
          if (pointInRect(wx, wy, p)) return p;
        }
        return null;
      }

      function firePickAtScreen(sx, sy){
        const w = screenToWorld(sx, sy);
        const hit = pickPlot(w.x, w.y);
        sceneState.selectedPlotId = hit ? hit.id : null;

        if (hit && typeof onPlotClick === "function") {
          const anchorW = { x: hit.x + hit.w/2, y: hit.y + hit.h };
          const anchorS = worldToScreen(anchorW.x, anchorW.y);
          onPlotClick(hit, sx, sy, anchorW, anchorS);
        }
      }

      // ---- Pointer pan/pinch/tap ----
      const pointers = new Map(); // pointerId -> {x,y}
      let isPanning = false;
      let panStart = { x:0, y:0, camX:0, camY:0 };
      let down = null; // {x,y,time, moved, multi}
      let pinchStart = null; // {dist, zoom, mid:{x,y}}

      const TAP_MOVE_PX = 10;

      function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
      function mid(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const p = eventToCanvasXY(e);
        const factor = e.deltaY < 0 ? 1.12 : 1/1.12;
        zoomAt(factor, p.x, p.y);
      }, { passive:false });

      canvas.addEventListener("pointerdown", (e) => {
        canvas.setPointerCapture(e.pointerId);
        const p = eventToCanvasXY(e);
        pointers.set(e.pointerId, p);

        if (pointers.size === 1) {
          isPanning = true;
          panStart = { x:p.x, y:p.y, camX:cam.x, camY:cam.y };
          down = { x:p.x, y:p.y, time:performance.now(), moved:false, multi:false };
        } else if (pointers.size === 2) {
          // start pinch
          const [a,b] = Array.from(pointers.values());
          pinchStart = {
            dist: dist(a,b),
            zoom: cam.zoom,
            mid: mid(a,b),
          };
          if (down) down.multi = true;
          isPanning = false;
        } else {
          if (down) down.multi = true;
          isPanning = false;
        }
      }, { passive:true });

      canvas.addEventListener("pointermove", (e) => {
        if (!pointers.has(e.pointerId)) return;
        const p = eventToCanvasXY(e);
        pointers.set(e.pointerId, p);

        if (pointers.size === 1 && isPanning) {
          cam.x = panStart.camX - (p.x - panStart.x) / cam.zoom;
          cam.y = panStart.camY - (p.y - panStart.y) / cam.zoom;
          clampCameraToMap();

          if (down && !down.moved) {
            if (Math.hypot(p.x-down.x, p.y-down.y) > TAP_MOVE_PX) down.moved = true;
          }
        } else if (pointers.size === 2 && pinchStart) {
          const [a,b] = Array.from(pointers.values());
          const d = dist(a,b);
          const scale = pinchStart.dist ? (d / pinchStart.dist) : 1;

          const before = screenToWorld(pinchStart.mid.x, pinchStart.mid.y);
          cam.minZoom = computeMinZoomToFit();
          cam.zoom = clamp(pinchStart.zoom * scale, cam.minZoom, cam.maxZoom);
          const after = screenToWorld(pinchStart.mid.x, pinchStart.mid.y);

          cam.x += (before.x - after.x);
          cam.y += (before.y - after.y);
          clampCameraToMap();

          if (down) down.multi = true;
        }
      }, { passive:true });

      canvas.addEventListener("pointerup", (e) => {
        const p = eventToCanvasXY(e);
        pointers.delete(e.pointerId);

        const wasTap = down && !down.moved && !down.multi;
        const recent = down && (performance.now() - down.time) < 650;

        if (wasTap && recent) {
          firePickAtScreen(p.x, p.y);
        }

        if (pointers.size === 1) {
          // if one pointer remains, resume pan from its position
          const only = Array.from(pointers.values())[0];
          isPanning = true;
          panStart = { x: only.x, y: only.y, camX: cam.x, camY: cam.y };
        } else {
          isPanning = false;
          pinchStart = null;
        }

        down = null;
      }, { passive:true });

      canvas.addEventListener("pointercancel", (e) => {
        pointers.delete(e.pointerId);
        isPanning = false;
        pinchStart = null;
        down = null;
      }, { passive:true });

      async function init(){
        resizeCanvas();
        baseImg = await loadImage(baseMapSrc);
        baseW = baseImg.width; baseH = baseImg.height;

        cam.x = baseW/2; cam.y = baseH/2;
        cam.minZoom = computeMinZoomToFit();
        cam.zoom = Math.max(cam.zoom, cam.minZoom);
        clampCameraToMap();
      }
      init().catch(err => console.error("City init failed:", err));

      function drawBase(){
        const cx = canvas.width/2, cy = canvas.height/2;

        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = "#0f1220";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.setTransform(cam.zoom, 0, 0, cam.zoom, cx - cam.x*cam.zoom, cy - cam.y*cam.zoom);
        ctx.imageSmoothingEnabled = false;

        if (baseImg) ctx.drawImage(baseImg, 0, 0);
      }

      function drawPlacedBuildings() {
        if (!buildingsSystem) return;
        const placed = buildingsSystem.getAllPlaced?.() || [];
        if (!placed.length) return;

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        ctx.setTransform(cam.zoom, 0, 0, cam.zoom, cx - cam.x * cam.zoom, cy - cam.y * cam.zoom);
        ctx.imageSmoothingEnabled = false;

        for (const b of placed) {
          const plot = sceneState.plots.find(p => p.id === b.plotId);
          if (!plot) continue;

          const ax = plot.x + plot.w / 2;
          const ay = plot.y + plot.h;

          ctx.drawImage(
            b.img,
            Math.round(ax - b.w / 2),
            Math.round(ay - b.h),
            b.w,
            b.h
          );
        }
      }

      function drawPlotsOverlay(){
        ctx.setTransform(1,0,0,1,0,0);

        for (const p of sceneState.plots) {
          const a = worldToScreen(p.x, p.y);
          const b = worldToScreen(p.x+p.w, p.y+p.h);

          const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
          const w = Math.abs(b.x-a.x), h = Math.abs(b.y-a.y);

          const sel = p.id === sceneState.selectedPlotId;
          ctx.lineWidth = sel ? 3 : 2;
          ctx.strokeStyle = sel ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";
          ctx.strokeRect(x,y,w,h);

          if (sel) {
            ctx.fillStyle = "rgba(255,255,255,0.08)";
            ctx.fillRect(x,y,w,h);
          }
        }
      }

      return {
        setPlots(plots){ sceneState.plots = plots; },
        setBuildingsSystem(sys){ buildingsSystem = sys; },
        setOnPlotClick(fn){ onPlotClick = fn; },

        update(){ resizeCanvas(); cam.minZoom = computeMinZoomToFit(); clampCameraToMap(); },
        render(){ drawBase(); drawPlacedBuildings(); drawPlotsOverlay(); },

        worldToScreen,
        getMapWidth(){ return baseW; },
        getMapHeight(){ return baseH; },
        getCamera(){ return { ...cam }; }
      };
    }

    // =========================================================
    // 4) BOOT SCENE + SYSTEMS
    // =========================================================
    const canvas = document.getElementById("cityCanvas");
    const scene = createCityScene(canvas, { baseMapSrc: BASE_MAP_SRC });
    scene.setPlots(CITY_PLOTS);

    const buildings = createcitybuildingsSystem({ basePath: BUILDING_BASE_PATH });
    scene.setBuildingsSystem(buildings);

    const hasPendingLoad = !!sessionStorage.getItem(PENDING_KEY);
    if (!hasPendingLoad) await buildings.ensureTownhall("townhall");

    // =========================================================
    // 5) UI OVERLAY RECT (map -> css px)
    // =========================================================
    const uiOverlay = document.getElementById("uiOverlay");
    const resourceBar = document.getElementById("resourceBar");
    const resourceLeft = document.getElementById("resourceLeft");

    const popup = document.getElementById("buildPopup");
    const buildTitle = document.getElementById("buildTitle");
    const buildGrid = document.getElementById("buildGrid");

    const barracksPanel = document.getElementById("barracksPanel");

    let currentBuildPlot = null;
    let barracksTab = "train";

    const clampNum = (v, a, b) => {
      v = Number(v);
      if (!Number.isFinite(v)) return a;
      return Math.max(a, Math.min(b, v));
    };

    function getMapSizeSafe(){
      const w = (typeof scene.getMapWidth === "function") ? scene.getMapWidth() : 512;
      const h = (typeof scene.getMapHeight === "function") ? scene.getMapHeight() : 512;
      return { w, h };
    }

    function worldToScreenSafe(wx, wy){
      if (typeof scene.worldToScreen === "function") return scene.worldToScreen(wx, wy);
      return { x: wx, y: wy };
    }

    function canvasPxToCssPage(canvasPxX, canvasPxY){
      const r = canvas.getBoundingClientRect();
      return {
        x: r.left + (canvasPxX / canvas.width) * r.width,
        y: r.top  + (canvasPxY / canvas.height) * r.height
      };
    }

    function updateUiOverlayRect(){
      const { w: mapW, h: mapH } = getMapSizeSafe();
      const a = worldToScreenSafe(0, 0);
      const b = worldToScreenSafe(mapW, mapH);
      const A = canvasPxToCssPage(a.x, a.y);
      const B = canvasPxToCssPage(b.x, b.y);

      const left   = Math.min(A.x, B.x);
      const top    = Math.min(A.y, B.y);
      const right  = Math.max(A.x, B.x);
      const bottom = Math.max(A.y, B.y);

      uiOverlay.style.left = `${left}px`;
      uiOverlay.style.top = `${top}px`;
      uiOverlay.style.width = `${right - left}px`;
      uiOverlay.style.height = `${bottom - top}px`;
    }

    // =========================================================
    // 6) PANEL PLACEMENT (CENTER ONLY ON OPEN/RESIZE)
    // =========================================================
    function centerPanelOnScreen(panelEl){
      const r = canvas.getBoundingClientRect();
      const overlayRect = uiOverlay.getBoundingClientRect();

      panelEl.style.display = "block";
      panelEl.style.visibility = "hidden";
      panelEl.style.left = "0px";
      panelEl.style.top  = "0px";

      const pw = panelEl.offsetWidth;
      const ph = panelEl.offsetHeight;

      panelEl.style.visibility = "visible";

      const targetPageX = r.left + r.width / 2;
      const targetPageY = r.top  + r.height / 2;

      const localX = targetPageX - overlayRect.left - pw / 2;
      const localY = targetPageY - overlayRect.top  - ph / 2;

      const pad = 12;
      const barH = resourceBar.offsetHeight || 64;

      const x = clampNum(localX, pad, Math.max(pad, overlayRect.width - pw - pad));
      const y = clampNum(localY, pad + barH, Math.max(pad + barH, overlayRect.height - ph - pad));

      panelEl.style.left = `${x}px`;
      panelEl.style.top  = `${y}px`;
    }

    // =========================================================
    // 7) iOS GHOST TAP / DOUBLE FIRE PROTECTION
    // =========================================================
    let lastUiActionAt = 0;
    function markUiAction(){ lastUiActionAt = performance.now(); }
    function uiJustHappened(ms = 450){ return (performance.now() - lastUiActionAt) < ms; }

    // Delegated UI handler uses capture phase to block canvas, and handles action itself.
    let lastDelegatedFire = 0;

    function isUiTargetEvent(e){
      return !!e.target?.closest?.("#resourceBar, .uiPanel");
    }

    uiOverlay.addEventListener("pointerdown", (e) => {
      if (!isUiTargetEvent(e)) return;
      markUiAction();
      e.stopPropagation();
    }, { capture:true, passive:true });

    uiOverlay.addEventListener("pointerup", async (e) => {
      if (!isUiTargetEvent(e)) return;

      // dedupe fast double pointer events
      const now = performance.now();
      if (now - lastDelegatedFire < 250) return;
      lastDelegatedFire = now;

      markUiAction();
      e.preventDefault();
      e.stopPropagation();

      const btn = e.target?.closest?.("[data-action]");
      if (!btn) return;

      const action = btn.getAttribute("data-action");

      try {
        await handleUiAction(action, btn);
      } catch (err) {
        console.error("UI action failed:", action, err);
      }
    }, { capture:true, passive:false });

    // =========================================================
    // 8) COST + ECON HELPERS
    // =========================================================
    function fmtCost(cost) {
      if (!cost) return "";
      const parts = [];
      if (cost.food)  parts.push(`F:${cost.food}`);
      if (cost.wood)  parts.push(`W:${cost.wood}`);
      if (cost.stone) parts.push(`S:${cost.stone}`);
      if (cost.ore)   parts.push(`O:${cost.ore}`);
      if (cost.gold)  parts.push(`G:${cost.gold}`);
      return parts.length ? parts.join(" ") : "";
    }

    function fmtCostPretty(cost){
      if (!cost) return "?";
      const parts = [];
      if (cost.food)  parts.push(`F:${cost.food}`);
      if (cost.wood)  parts.push(`W:${cost.wood}`);
      if (cost.stone) parts.push(`S:${cost.stone}`);
      if (cost.ore)   parts.push(`O:${cost.ore}`);
      if (cost.gold)  parts.push(`G:${cost.gold}`);
      return parts.length ? parts.join("  ") : "?";
    }

    function isResourceUnlocked(res) {
      if (res === "stone") return !!buildings.getByBuildingId?.("quarry");
      if (res === "ore")   return !!buildings.getByBuildingId?.("mine");
      return true;
    }

    function canAfford(cost) {
      if (!cost) return true;
      for (const k in cost) {
        const need = Number(cost[k] ?? 0);
        if (need <= 0) continue;
        if (!isResourceUnlocked(k)) return false;
        if ((state?.resources?.[k] ?? 0) < need) return false;
      }
      return true;
    }

    // =========================================================
    // 9) STATE SYNC FROM BUILDINGS PLACED
    // =========================================================
    function syncLevelsFromPlaced() {
      const lv = (state.buildings.levels ||= {});
      lv.townhall = 0;
      lv.house = 0;
      lv.farm = 0;
      lv.lumber = 0;
      lv.quarry = 0;
      lv.mine = 0;
      lv.barracks = 0;
      lv.academy = 0;
      lv.commandcenter = 0;

      for (const plot of CITY_PLOTS) {
        const placed = buildings.getPlacedOnPlot(plot.id);
        if (!placed) continue;
        const key = placed.buildingId;
        if (Object.prototype.hasOwnProperty.call(lv, key)) lv[key] = placed.level ?? 1;
      }
      state.buildings.townhallLevel = lv.townhall || 0;
    }

    // =========================================================
    // 10) BUILD POPUP RENDER (NO per-button listeners)
    // =========================================================
    function renderBuildPopupForPlot(plot){
      currentBuildPlot = plot;
      const existing = buildings.getPlacedOnPlot(plot.id);

      buildGrid.innerHTML = "";

      if (existing) {
        const lvl = existing.level ?? 1;
        const def = BUILDINGS[existing.buildingId];
        const name = def?.name || existing.buildingId;

        const chk = buildings.canUpgradePlot(plot.id);
        const upgradeCost = def?.upgradeCost ? def.upgradeCost(lvl) : null;
        const affordable = canAfford(upgradeCost);
        const disabled = (!chk.ok || !affordable || !upgradeCost);

        buildTitle.textContent = `Plot: ${plot.id} (Occupied)`;

        buildGrid.innerHTML = `
          <div class="upCard">
            <div class="upTitle">${name}</div>

            <div class="upRow"><span>Current Level</span><b>${lvl}</b></div>
            <div class="upRow"><span>Cost</span><span class="upCost">${fmtCostPretty(upgradeCost)}</span></div>

            <button class="upBtn" type="button" data-action="build-upgrade" ${disabled ? "disabled" : ""}>
              Upgrade → Lv ${lvl + 1}
            </button>

            ${!chk.ok ? `<div class="upReason">${chk.reason}</div>` : ""}
            ${(chk.ok && upgradeCost && !affordable) ? `<div class="upReason">Not enough resources</div>` : ""}
          </div>
        `;
      } else {
        buildTitle.textContent = `Plot: ${plot.id} (Build)`;

        const frag = document.createDocumentFragment();

        for (const bKey of Object.keys(BUILDINGS).filter(k => k !== "townhall")) {
          const def = BUILDINGS[bKey];
          const cost = def?.cost || null;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "buildBtn";
          btn.setAttribute("data-action", "build-place");
          btn.setAttribute("data-building-id", bKey);
          btn.textContent = `${def?.name || bKey}${cost ? `\n${fmtCost(cost)}` : ""}`;

          const gate = buildings.canBuildBuilding?.(bKey) ?? { ok:true };

          if (!gate.ok) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = gate.reason;
          } else if (cost && !canAfford(cost)) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = "Not enough resources";
          }

          frag.appendChild(btn);
        }

        buildGrid.appendChild(frag);
      }

      popup.style.display = "block";
      centerPanelOnScreen(popup);
    }

    // =========================================================
    // 11) BARRACKS PANEL RENDER (delegation-ready)
    // =========================================================
    function fmtMMSS(ms) {
      const total = Math.max(0, Math.ceil(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function unlockedTiersForBarracksLevel(lvl) {
      const tiers = [];
      for (const tier of ["T1","T2","T3","T4"]) {
        if ((BARRACKS_TIER_UNLOCK?.[tier] ?? 999) <= lvl) tiers.push(tier);
      }
      return tiers;
    }

    function troopOptionsForBarracksLevel(barracksLevel) {
      const allowed = new Set(unlockedTiersForBarracksLevel(barracksLevel));
      return Object.values(TROOPS)
        .filter(t => allowed.has(t.tier))
        .map(t => ({ id: t.id, label: t.label ?? t.id }));
    }

    function getBarracksLevelSafe() {
      return Number(state?.buildings?.levels?.barracks || 0);
    }

    function findBarracksPlot(){
      return CITY_PLOTS.find(p => buildings.getPlacedOnPlot(p.id)?.buildingId === "barracks") || null;
    }

    function normalizeSlots(snap){
      let slots = snap?.slots ?? snap?.items ?? snap?.queue ?? snap?.queues?.barracks ?? snap?.queues;
      if (!Array.isArray(slots)) slots = slots ? Object.values(slots).flat() : [];
      return slots.map((s) => {
        if (s?.active) {
          const job = s.active;
          const now = Date.now();
          const totalMs = job.totalMs ?? Math.max(1, (job.endAt ?? now) - (job.startAt ?? now));
          const remainingMs = Math.max(0, (job.endAt ?? now) - now);
          return { status:"training", troopId:job.troopId, amount:job.amount, totalMs, remainingMs };
        }
        if (s?.status) return s;
        return { status:"idle" };
      });
    }

    function renderBarracksPanel(){
      const barracksLevel = getBarracksLevelSafe();
      try { syncBarracksSlots?.(barracksLevel); } catch {}

      const snap = getTrainingSnapshot?.("barracks") ?? {};
      const normalized = normalizeSlots(snap);
      const opts = troopOptionsForBarracksLevel(barracksLevel);

      const trainHtml = normalized.map((s, i) => {
        const isIdle = s.status === "idle" || !s.troopId;

        if (isIdle) {
          const options = opts.map(o => `<option value="${o.id}">${o.label}</option>`).join("");
          return `
            <div style="border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:12px;margin:10px 0;">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <b>Slot ${i+1}</b>
                <span style="opacity:.7">Idle</span>
              </div>

              <div style="display:flex;gap:8px;margin-top:10px;">
                <select data-slot="${i}" data-role="troop"
                  style="flex:1; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.12);
                  border-radius:12px; padding:10px;">
                  ${options || `<option value="">(No troops unlocked)</option>`}
                </select>

                <input data-slot="${i}" data-role="amt" type="number" min="1" value="1"
                  style="width:92px; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.12);
                  border-radius:12px; padding:10px;" />
              </div>

              <button type="button" data-action="bx-start" data-slot="${i}"
                style="margin-top:10px; width:100%; background:#2563eb; color:white; border:0;
                border-radius:12px; padding:12px; font-weight:900; cursor:pointer; touch-action:manipulation;">
                Train
              </button>
            </div>
          `;
        }

        const pct = s.totalMs ? Math.min(100, Math.max(0, 100 * (1 - s.remainingMs / s.totalMs))) : 0;
        return `
          <div style="border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:12px;margin:10px 0;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <b>Slot ${i+1}</b>
              <span style="opacity:.9">${s.troopId} × ${s.amount}</span>
            </div>

            <div style="margin-top:10px; height:10px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden;">
              <div style="height:100%; width:${pct}%; background:rgba(37,99,235,.95);"></div>
            </div>

            <div style="display:flex; justify-content:space-between; margin-top:8px; opacity:.85;">
              <span>${fmtMMSS(s.remainingMs)} left</span>
              <span>${Math.round(pct)}%</span>
            </div>

            <button type="button" data-action="bx-cancel" data-slot="${i}"
              style="margin-top:10px; width:100%; background:rgba(239,68,68,.95); color:white; border:0;
              border-radius:12px; padding:12px; font-weight:900; cursor:pointer; touch-action:manipulation;">
              Cancel
            </button>
          </div>
        `;
      }).join("");

      const barracksPlot = findBarracksPlot();
      const barracksPlaced = barracksPlot ? buildings.getPlacedOnPlot(barracksPlot.id) : null;

      let upgradeBlock = `<div style="opacity:.85">No barracks placed yet.</div>`;
      if (barracksPlaced && barracksPlot) {
        const lvl = barracksPlaced.level ?? 1;
        const chk = buildings.canUpgradePlot(barracksPlot.id);
        const def = BUILDINGS?.barracks;
        const upgradeCost = def?.upgradeCost ? def.upgradeCost(lvl) : null;
        const affordable = canAfford(upgradeCost);
        const disabled = (!chk.ok || (upgradeCost && !affordable) || !upgradeCost);

        upgradeBlock = `
          <div class="upCard">
            <div class="upTitle">Barracks</div>
            <div class="upRow"><span>Current Level:</span> <b>${lvl}</b></div>
            <div class="upRow"><span>Cost:</span> <span class="upCost">${fmtCostPretty(upgradeCost)}</span></div>

            <button type="button" class="upBtn" data-action="bx-upgrade" ${disabled ? "disabled" : ""}>
              Upgrade → Lv ${lvl+1}
            </button>

            ${(!chk.ok ? `<div class="upReason">${chk.reason}</div>` : "")}
            ${(chk.ok && upgradeCost && !affordable ? `<div class="upReason">Not enough resources</div>` : "")}

            <div class="upHint">Tiers unlock: L1=T1, L5=T2, L10=T3, L15=T4</div>
          </div>
        `;
      }

      barracksPanel.innerHTML = `
        <div class="bxHeader">
          <div>
            <div style="font-size:14px;font-weight:900;">Barracks</div>
            <div style="opacity:.7;margin-top:2px;">L${barracksLevel}</div>
          </div>
          <button id="barracksCloseBtn" class="bxClose" type="button" data-action="bx-close">Close</button>
        </div>

        <div class="bxWrap">
          <div class="bxTabs">
            <button class="bxTab ${barracksTab==="train"?"active":""}" data-action="bx-tab" data-tab="train" type="button">Train</button>
            <button class="bxTab ${barracksTab==="upgrade"?"active":""}" data-action="bx-tab" data-tab="upgrade" type="button">Upgrade</button>
          </div>

          <div class="bxMain">
            <div id="bxTab_train" style="display:${barracksTab==="train"?"block":"none"};">
              ${trainHtml || `<div style="opacity:.8">No slots found.</div>`}
              <div class="upHint">Tiers unlock: L1=T1, L5=T2, L10=T3, L15=T4</div>
            </div>

            <div id="bxTab_upgrade" style="display:${barracksTab==="upgrade"?"block":"none"};">
              ${upgradeBlock}
            </div>
          </div>
        </div>
      `;
    }

    // =========================================================
    // 12) UI ACTION ROUTER (EVENT DELEGATION)
    // =========================================================
    async function handleUiAction(action, el){
      if (action === "build-close") {
        popup.style.display = "none";
        return;
      }

      if (action === "build-upgrade") {
        const plot = currentBuildPlot;
        if (!plot) return;

        const res = await buildings.upgradePlot(plot.id);
        if (!res?.ok) { alert(res?.reason || "Upgrade failed"); return; }

        syncLevelsFromPlaced();
        renderBuildPopupForPlot(plot); // immediately refresh to next level
        centerPanelOnScreen(popup);
        return;
      }

      if (action === "build-place") {
        const plot = currentBuildPlot;
        if (!plot) return;

        const bKey = el.getAttribute("data-building-id");
        if (!bKey) return;

        const r = await buildings.placeBuildingOnPlot(plot.id, bKey, 1);
        if (r && r.ok === false) alert(r.reason || "Could not build.");

        syncLevelsFromPlaced();
        popup.style.display = "none";
        return;
      }

      if (action === "bx-close") {
        barracksPanel.style.display = "none";
        return;
      }

      if (action === "bx-tab") {
        barracksTab = el.getAttribute("data-tab") || "train";
        renderBarracksPanel();
        centerPanelOnScreen(barracksPanel);
        return;
      }

      if (action === "bx-start") {
        const barracksLevel = getBarracksLevelSafe();
        const slotIndex = Number(el.getAttribute("data-slot"));
        const troopSel = barracksPanel.querySelector(`select[data-slot="${slotIndex}"][data-role="troop"]`);
        const amtInp  = barracksPanel.querySelector(`input[data-slot="${slotIndex}"][data-role="amt"]`);

        const troopId = troopSel?.value;
        const amount = Math.max(1, Number(amtInp?.value || 1));
        if (!troopId) return alert("No troop selected / unlocked.");

        const res = startTrainingInSlot({ barracksLevel, slotIndex, troopId, amount });
        if (!res?.ok) alert(res?.reason || "Could not start training.");

        renderBarracksPanel();
        centerPanelOnScreen(barracksPanel);
        return;
      }

      if (action === "bx-cancel") {
        const slotIndex = Number(el.getAttribute("data-slot"));
        if (!confirm("Cancel this training slot?")) return;

        const res = cancelTraining?.({ slotIndex, refundPercent: 0.5 });
        if (res && res.ok === false) alert(res.reason || "Could not cancel.");

        renderBarracksPanel();
        centerPanelOnScreen(barracksPanel);
        return;
      }

      if (action === "bx-upgrade") {
        const barracksPlot = findBarracksPlot();
        if (!barracksPlot) return;

        const r = await buildings.upgradePlot(barracksPlot.id);
        if (r && r.ok === false) { alert(r.reason || "Upgrade failed."); return; }

        syncLevelsFromPlaced();
        renderBarracksPanel();
        centerPanelOnScreen(barracksPanel);
        return;
      }
    }

    // =========================================================
    // 13) PLOT CLICK BEHAVIOR (BLOCK IMMEDIATELY AFTER UI TAPS)
    // =========================================================
    scene.setOnPlotClick((plot) => {
      if (!plot) return;
      if (uiJustHappened()) return;

      const existing = buildings.getPlacedOnPlot(plot.id);
      const isBarracks = existing?.buildingId === "barracks";

      if (isBarracks) {
        popup.style.display = "none";
        barracksTab = "train";
        barracksPanel.style.display = "block";
        renderBarracksPanel();
        centerPanelOnScreen(barracksPanel);
        return;
      }

      barracksPanel.style.display = "none";
      renderBuildPopupForPlot(plot);
    });

    // =========================================================
    // 14) ECONOMY + RESOURCE BAR
    // =========================================================
    const fmt = (n) => Math.floor(n || 0).toLocaleString();
    const fmtRate = (n) => (Math.round((n || 0) * 10) / 10).toLocaleString();

    function renderResourceBar(){
      const p = getProductionPerSecond();
      resourceLeft.innerHTML = `
        <div class="resItem"><b>Food</b> ${fmt(state.resources.food)} <span>(+${fmtRate(p.food)}/s)</span></div>
        <div class="resItem"><b>Wood</b> ${fmt(state.resources.wood)} <span>(+${fmtRate(p.wood)}/s)</span></div>
        <div class="resItem"><b>Stone</b> ${fmt(state.resources.stone)} <span>(+${fmtRate(p.stone)}/s)</span></div>
        <div class="resItem"><b>Ore</b> ${fmt(state.resources.ore)} <span>(+${fmtRate(p.ore)}/s)</span></div>
        <div class="resItem"><b>Gold</b> ${fmt(state.resources.gold)} <span>(+${fmtRate(p.gold)}/s)</span></div>
        <div class="resItem" style="opacity:.9"><b>TH</b> ${state.buildings?.levels?.townhall || 0}</div>
      `;
    }

    let econLast = 0;
    function economyFrame(t){
      const dt = econLast ? (t - econLast) / 1000 : 0;
      econLast = t;
      updateEconomy(dt);
      renderResourceBar();
      requestAnimationFrame(economyFrame);
    }
    requestAnimationFrame(economyFrame);

    // =========================================================
    // 15) SAVE / LOAD
    // =========================================================
    function buildSavePayload() {
      syncLevelsFromPlaced();
      const placed = [];
      for (const plot of CITY_PLOTS) {
        const p = buildings.getPlacedOnPlot(plot.id);
        if (!p) continue;
        placed.push({ plotId: plot.id, buildingId: p.buildingId, level: p.level ?? 1 });
      }
      return {
        v: 1,
        ts: Date.now(),
        resources: { ...state.resources },
        levels: { ...state.buildings.levels },
        placed,
      };
    }

    function saveGame() {
      try {
        const payload = buildSavePayload();
        const json = JSON.stringify(payload);
        localStorage.setItem(SAVE_KEY, json);

        const btn = document.getElementById("btnSave");
        if (btn) {
          const prev = btn.textContent;
          btn.textContent = "Saved ✓";
          setTimeout(() => (btn.textContent = prev), 900);
        }
      } catch (e) {
        console.error("SAVE FAILED:", e);
      }
    }

    function loadGame() {
      try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) return console.warn("No save found.");
        sessionStorage.setItem(PENDING_KEY, raw);
        location.reload();
      } catch (e) {
        console.error("LOAD FAILED:", e);
      }
    }

    function resetSave() {
      localStorage.removeItem(SAVE_KEY);
      sessionStorage.removeItem(PENDING_KEY);
      location.reload();
    }

    async function applyPayload(data) {
      if (!data || typeof data !== "object") return false;

      if (data.resources) {
        state.resources.food  = Number(data.resources.food  ?? 0);
        state.resources.wood  = Number(data.resources.wood  ?? 0);
        state.resources.stone = Number(data.resources.stone ?? 0);
        state.resources.ore   = Number(data.resources.ore   ?? 0);
        state.resources.gold  = Number(data.resources.gold  ?? 0);
      }

      if (typeof buildings.resetAllPlaced === "function") buildings.resetAllPlaced();

      if (Array.isArray(data.placed)) {
        for (const rec of data.placed) {
          const plotId = String(rec.plotId);
          const buildingId = String(rec.buildingId);
          const targetLevel = Math.max(1, Number(rec.level ?? 1));

          await buildings.placeBuildingOnPlot(plotId, buildingId, 1);

          for (let lvl = 1; lvl < targetLevel; lvl++) {
            const r = await buildings.upgradePlot(plotId);
            if (r && r.ok === false) break;
          }
        }
      }

      await buildings.ensureTownhall("townhall");
      syncLevelsFromPlaced();
      return true;
    }

    (async function bootLoad() {
      const pending = sessionStorage.getItem(PENDING_KEY);
      if (!pending) return;
      sessionStorage.removeItem(PENDING_KEY);

      try {
        const data = JSON.parse(pending);
        await applyPayload(data);
      } catch (e) {
        console.error("Pending load failed:", e);
      }
    })();

    document.getElementById("btnSave").onclick = saveGame;
    document.getElementById("btnLoad").onclick = loadGame;
    document.getElementById("btnReset").onclick = resetSave;
    setInterval(() => { try { saveGame(); } catch {} }, 10000);

    // =========================================================
    // 16) MAIN LOOP
    // =========================================================
    window.addEventListener("resize", () => {
      updateUiOverlayRect();
      if (popup.style.display !== "none") centerPanelOnScreen(popup);
      if (barracksPanel.style.display !== "none") centerPanelOnScreen(barracksPanel);
    });

    // smooth refresh while training
    setInterval(() => {
      if (barracksPanel.style.display === "none") return;

      const snap = getTrainingSnapshot?.("barracks") ?? {};
      const slots = normalizeSlots(snap);
      const anyTraining = slots.some(s => s.status === "training");
      if (!anyTraining) return;

      requestAnimationFrame(() => {
        renderBarracksPanel();
        centerPanelOnScreen(barracksPanel);
      });
    }, 250);

    function frame(){
      scene.update();
      scene.render();

      processTrainingQueues();
      updateUiOverlayRect();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
</body>
</html>
