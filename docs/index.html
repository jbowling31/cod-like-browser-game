<!-- docs/index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Empire</title>

  <style>
    html, body { height:100%; margin:0; background:#0f1220; overflow:hidden; }
    canvas{
      position:fixed; inset:0; width:100%; height:100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action:none;
      display:block;
    }

    /* =============================
       FIXED HUD + PANELS (viewport)
    ============================== */
    #uiFixed{
      position:fixed;
      inset:0;
      z-index:1000;
      pointer-events:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:#eaf0ff;

      /* iPhone notch / home bar */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }

    /* ---------- TOP HUD ---------- */
    .hudTop{
      position:fixed;
      left:0; right:0;
      top:0;
      padding-top: env(safe-area-inset-top);
      pointer-events:none;
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px 8px;
      background:linear-gradient(180deg, rgba(10,14,30,.92), rgba(0,0,0,.35));
      border-bottom:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 -1px 0 rgba(255,255,255,.06);
    }

    .pill{
      pointer-events:auto;
      display:flex;
      align-items:center;
      gap:10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      padding:8px 10px;
      user-select:none;
      touch-action:manipulation;
    }

    .resourcePill{
      overflow:auto;
      white-space:nowrap;
      max-width: calc(100vw - 160px);
      scrollbar-width:none;
    }
    .resourcePill::-webkit-scrollbar{ display:none; }

    .r{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-weight:900;
      letter-spacing:.2px;
      font-size:13px;
      opacity:.95;
    }
    .r small{
      font-weight:700;
      opacity:.7;
      margin-left:2px;
    }

    .rightPill{ gap:8px; }
    .iconBtn{
      pointer-events:auto;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      color:#eaf0ff;
      border-radius:12px;
      padding:9px 10px;
      font:13px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      touch-action:manipulation;
    }
    .iconBtn:hover{
      background:rgba(255,255,255,.14);
      border-color:rgba(255,255,255,.22);
      transform: translateY(-1px);
    }
    .iconBtn:active{ transform: translateY(0px); }

    /* ---------- MID HUD (queue/timers) ---------- */
    .hudMid{
      position:fixed;
      left:0; right:0;
      top:64px;
      padding-top: env(safe-area-inset-top);
      pointer-events:none;
      display:flex;
      justify-content:center;
      padding:8px 10px;
    }
    .queuePill{
      pointer-events:auto;
      gap:14px;
      font-weight:900;
      font-size:13px;
      opacity:.95;
    }
    #queueText, #timerText{ opacity:.95; }

    /* ---------- BOTTOM HUD ---------- */
    .hudBottom{
      position:fixed;
      left:0; right:0;
      bottom:0;
      padding-bottom: env(safe-area-inset-bottom);
      pointer-events:none;
      display:flex;
      justify-content:center;
      gap:10px;
      padding:10px 10px 12px;
      background:linear-gradient(0deg, rgba(10,14,30,.92), rgba(0,0,0,.25));
      border-top:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 -10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06);
    }

    .bigBtn{
      pointer-events:auto;
      min-width:92px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      color:#eaf0ff;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      touch-action:manipulation;
    }
    .bigBtn:hover{
      background:rgba(255,255,255,.14);
      border-color:rgba(255,255,255,.22);
      transform: translateY(-1px);
    }
    .bigBtn:active{ transform: translateY(0px); }

    .bigBtn.primary{
      background:#22c55e;
      border-color: rgba(34,197,94,.55);
      color:#06210f;
      box-shadow: 0 12px 26px rgba(34,197,94,.18);
    }

    /* =============================
       PANELS (Build/Barracks/Settings)
    ============================== */
    #panels{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:1100;
    }

    .uiPanel{
      pointer-events:auto;
      position:absolute;
      min-width:280px;
      max-width:420px;
      background:rgba(0,0,0,.78);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      touch-action:manipulation;
    }
    .uiPanel, .uiPanel * { pointer-events:auto; }

    #buildPopup{ display:none; }
    #settingsPanel{ display:none; width:380px; }
    #barracksPanel{ display:none; width:420px; max-height:70vh; overflow:auto; }

    #buildTitle{ font-weight:900; margin-bottom:10px; font-size:14px; }
    .row{ display:flex; justify-content:flex-end; gap:10px; margin-top:12px; }

    .closeBtn{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      touch-action: manipulation;
    }
    .closeBtn:hover{ background:rgba(255,255,255,.16); }

    .buildBtn{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      text-align:left;
      white-space:pre-line;
      transition: background 120ms ease, transform 120ms ease;
      width:100%;
      touch-action: manipulation;
      margin-bottom:10px;
    }
    .buildBtn:hover{ background:rgba(255,255,255,.16); transform: translateY(-1px); }
    .buildBtn:active{ transform: translateY(0px); }

    .upCard{
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 14px;
      color: #e5e7eb;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
    }
    .upTitle{
      font-size: 18px;
      font-weight: 900;
      letter-spacing: .2px;
      margin-bottom: 8px;
      color:#ffffff;
    }
    .upRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size: 14px;
      margin: 6px 0;
      opacity: .95;
    }
    .upRow b{ font-weight: 900; }
    .upCost{ font-weight: 900; letter-spacing: .3px; }

    .upHint{
      margin-top: 10px;
      font-size: 12px;
      opacity: .78;
      line-height: 1.3;
    }
    .upBtn{
      margin-top: 12px;
      width: 100%;
      border: 0;
      border-radius: 14px;
      padding: 14px 14px;
      font-weight: 900;
      font-size: 16px;
      cursor: pointer;
      background: #22c55e;
      color: #06210f;
      box-shadow: 0 12px 26px rgba(34,197,94,.25);
      touch-action: manipulation;
    }
    .upBtn[disabled]{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.45);
      box-shadow: none;
      cursor: not-allowed;
    }

    .upReason{
      margin-top: 10px;
      font-size: 12px;
      opacity: .85;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
    }

    /* Settings */
    .setRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      margin-top:10px;
    }
    .setRow label{ display:flex; align-items:center; gap:10px; font-weight:900; }
    .setHint{ margin-top:10px; font-size:12px; opacity:.8; line-height:1.3; }
    .neutralBtn{
      margin-top:10px;
      width:100%;
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:12px 12px;
      font-weight:900;
      cursor:pointer;
      background:rgba(255,255,255,.10);
      color:#fff;
      touch-action:manipulation;
    }
    .neutralBtn:hover{ background:rgba(255,255,255,.16); }

    /* Barracks UI */
    .bxHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
    .bxClose{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      touch-action: manipulation;
    }
    .bxClose:hover{ background:rgba(255,255,255,.16); }
    .bxWrap{ display:flex; gap:12px; }
    .bxTabs{
      width:120px;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-right:10px;
      border-right:1px solid rgba(255,255,255,.10);
    }
    .bxTab{
      width:100%;
      text-align:left;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      cursor:pointer;
      font-weight:900;
      touch-action: manipulation;
    }
    .bxTab:hover{ background:rgba(255,255,255,.10); }
    .bxTab.active{
      background:rgba(34,197,94,.18);
      border-color:rgba(34,197,94,.35);
      color:#eafff2;
    }
    .bxMain{ flex:1; min-width:0; }
  </style>

  <link rel="icon" href="./favicon.ico">
</head>

<body>
  <canvas id="cityCanvas"></canvas>

  <!-- FIXED HUD -->
  <div id="uiFixed">
    <div class="hudTop">
      <div class="pill resourcePill" id="resourcePill">
        <span class="r" id="r_food">🍖 0</span>
        <span class="r" id="r_wood">🪵 0</span>
        <span class="r" id="r_stone">🪨 0</span>
        <span class="r" id="r_ore">⛏️ 0</span>
        <span class="r" id="r_gold">🪙 0</span>
        <span class="r" id="r_th">🏛️ TH 0</span>
      </div>

      <div class="pill rightPill">
        <button class="iconBtn" id="btnSettings" type="button" title="Settings">⚙️</button>
        <button class="iconBtn" id="btnSave" type="button" title="Save">💾</button>
        <button class="iconBtn" id="btnLoad" type="button" title="Load">⬇️</button>
        <button class="iconBtn" id="btnReset" type="button" title="Reset">↺</button>
      </div>
    </div>

    <div class="hudMid">
      <div class="pill queuePill" id="queuePill">
        <span id="queueText">Queue: 0/2</span>
        <span id="timerText">Timers: ON</span>
      </div>
    </div>

    <div class="hudBottom">
      <button class="bigBtn" id="btnCity" type="button">City</button>
      <button class="bigBtn" id="btnWorld" type="button">World</button>
      <button class="bigBtn primary" id="btnBuild" type="button">Build</button>
    </div>
  </div>

  <!-- PANELS -->
  <div id="panels">
    <div id="buildPopup" class="uiPanel">
      <div id="buildTitle">Build</div>
      <div id="buildGrid"></div>
      <div class="row">
        <button id="buildClose" class="closeBtn" type="button" data-action="build-close">Close</button>
      </div>
    </div>

    <div id="barracksPanel" class="uiPanel"></div>

    <div id="settingsPanel" class="uiPanel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
        <div style="font-weight:900; font-size:14px;">Settings</div>
        <button class="closeBtn" type="button" data-action="settings-close">Close</button>
      </div>

      <div class="setRow">
        <label>
          <input id="timersToggle" type="checkbox" />
          Build/Upgrade Timers
        </label>
        <span id="timersStateText" style="opacity:.85; font-weight:900;">ON</span>
      </div>

      <button class="neutralBtn" type="button" data-action="timers-finish-now">
        Finish any active timers now
      </button>

      <div class="setHint">
        Turn timers <b>OFF</b> to test instantly. If you toggle OFF while anything is in progress, it will auto-finish so you don’t get stuck.
      </div>
    </div>
  </div>

  <script type="module">
    import { CITY_PLOTS } from "./js/plots.city.js";
    import { BUILDINGS } from "./js/data/buildingCatalog.js";
    import { createCityBuildingsSystem } from "./js/systems/cityBuildings.js";
    import { state } from "./js/state.js";
    import { updateEconomy, getProductionPerSecond } from "./js/systems/cityEconomy.js";

    import {
      processTrainingQueues,
      getTrainingSnapshot,
      startTrainingInSlot,
      cancelTraining,
      syncBarracksSlots
    } from "./js/systems/trainingSystems.js";

    import { TROOPS, BARRACKS_TIER_UNLOCK } from "./js/data/troopsCatalog.js";

    const BASE_MAP_SRC = "./assets/maps/city/city_tilemap_base.png";
    const BUILDING_BASE_PATH = "./assets/city";
    const SAVE_KEY = "empire_city_save_v1";
    const PENDING_KEY = "EMPIRE_PENDING_LOAD";

    state.settings ??= {};
    if (typeof state.settings.timersEnabled !== "boolean") state.settings.timersEnabled = true;

    // Ensure resources exist
    state.resources ??= {};
    state.resources.food  ??= 0;
    state.resources.wood  ??= 0;
    state.resources.stone ??= 0;
    state.resources.ore   ??= 0;
    state.resources.gold  ??= 0;

    state.buildings ??= {};
    state.buildings.levels ??= {};

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function inferMapSizeFromPlots(plots, fallbackW = 512, fallbackH = 512){
      if (!Array.isArray(plots) || !plots.length) return { w: fallbackW, h: fallbackH };
      let maxX = 0, maxY = 0;
      for (const p of plots) {
        const x2 = (Number(p.x) || 0) + (Number(p.w) || 0);
        const y2 = (Number(p.y) || 0) + (Number(p.h) || 0);
        if (x2 > maxX) maxX = x2;
        if (y2 > maxY) maxY = y2;
      }
      return { w: Math.max(fallbackW, Math.ceil(maxX)), h: Math.max(fallbackH, Math.ceil(maxY)) };
    }

    function createCityScene(canvas, { baseMapSrc, initialMapSize }) {
      const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });
      ctx.imageSmoothingEnabled = false;

      let buildingsSystem = null;
      let onPlotClick = null;

      let baseImg = null;
      let baseW = initialMapSize?.w ?? 512;
      let baseH = initialMapSize?.h ?? 512;

      const cam = { x: baseW/2, y: baseH/2, zoom: 2, minZoom: 1, maxZoom: 6 };
      const sceneState = { plots: [], selectedPlotId: null };

      function resizeCanvas(){
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const r = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(r.width * dpr));
        const h = Math.max(1, Math.floor(r.height * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
          ctx.setTransform(1,0,0,1,0,0);
          ctx.imageSmoothingEnabled = false;
        }
      }

      function worldToScreen(wx, wy){
        const cx = canvas.width/2, cy = canvas.height/2;
        return { x:(wx-cam.x)*cam.zoom+cx, y:(wy-cam.y)*cam.zoom+cy };
      }
      function screenToWorld(sx, sy){
        const cx = canvas.width/2, cy = canvas.height/2;
        return { x:(sx-cx)/cam.zoom+cam.x, y:(sy-cy)/cam.zoom+cam.y };
      }

      function clampCameraToMap(){
        const viewW = canvas.width / cam.zoom;
        const viewH = canvas.height / cam.zoom;

        if (viewW >= baseW) cam.x = baseW / 2;
        else cam.x = clamp(cam.x, viewW/2, baseW - viewW/2);

        if (viewH >= baseH) cam.y = baseH / 2;
        else cam.y = clamp(cam.y, viewH/2, baseH - viewH/2);
      }

      function computeMinZoomToFit(){
        const zX = canvas.width / baseW;
        const zY = canvas.height / baseH;
        return Math.max(zX, zY);
      }

      function zoomAt(delta, sx, sy){
        const before = screenToWorld(sx, sy);
        cam.minZoom = computeMinZoomToFit();
        cam.zoom = clamp(cam.zoom * delta, cam.minZoom, cam.maxZoom);
        const after = screenToWorld(sx, sy);
        cam.x += (before.x - after.x);
        cam.y += (before.y - after.y);
        clampCameraToMap();
      }

      function eventToCanvasXY(e){
        const rect = canvas.getBoundingClientRect();
        return {
          x: (e.clientX - rect.left) * (canvas.width / rect.width),
          y: (e.clientY - rect.top)  * (canvas.height / rect.height)
        };
      }

      function pointInRect(px, py, r){
        return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
      }
      function pickPlot(wx, wy){
        for (let i = sceneState.plots.length - 1; i >= 0; i--) {
          const p = sceneState.plots[i];
          if (pointInRect(wx, wy, p)) return p;
        }
        return null;
      }

      function firePickAtScreen(sx, sy){
        const w = screenToWorld(sx, sy);
        const hit = pickPlot(w.x, w.y);
        sceneState.selectedPlotId = hit ? hit.id : null;

        if (hit && typeof onPlotClick === "function") {
          onPlotClick(hit);
        }
      }

      const pointers = new Map();
      let isPanning = false;
      let panStart = { x:0, y:0, camX:0, camY:0 };
      let down = null;
      let pinchStart = null;
      const TAP_MOVE_PX = 10;
      const dist = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
      const mid  = (a,b)=>({ x:(a.x+b.x)/2, y:(a.y+b.y)/2 });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const p = eventToCanvasXY(e);
        const factor = e.deltaY < 0 ? 1.12 : 1/1.12;
        zoomAt(factor, p.x, p.y);
      }, { passive:false });

      canvas.addEventListener("pointerdown", (e) => {
        canvas.setPointerCapture(e.pointerId);
        const p = eventToCanvasXY(e);
        pointers.set(e.pointerId, p);

        if (pointers.size === 1) {
          isPanning = true;
          panStart = { x:p.x, y:p.y, camX:cam.x, camY:cam.y };
          down = { x:p.x, y:p.y, time:performance.now(), moved:false, multi:false };
        } else if (pointers.size === 2) {
          const [a,b] = Array.from(pointers.values());
          pinchStart = { dist: dist(a,b), zoom: cam.zoom, mid: mid(a,b) };
          if (down) down.multi = true;
          isPanning = false;
        } else {
          if (down) down.multi = true;
          isPanning = false;
        }
      }, { passive:true });

      canvas.addEventListener("pointermove", (e) => {
        if (!pointers.has(e.pointerId)) return;
        const p = eventToCanvasXY(e);
        pointers.set(e.pointerId, p);

        if (pointers.size === 1 && isPanning) {
          cam.x = panStart.camX - (p.x - panStart.x) / cam.zoom;
          cam.y = panStart.camY - (p.y - panStart.y) / cam.zoom;
          clampCameraToMap();
          if (down && !down.moved && Math.hypot(p.x-down.x, p.y-down.y) > TAP_MOVE_PX) down.moved = true;
        } else if (pointers.size === 2 && pinchStart) {
          const [a,b] = Array.from(pointers.values());
          const d = dist(a,b);
          const scale = pinchStart.dist ? (d / pinchStart.dist) : 1;

          const before = screenToWorld(pinchStart.mid.x, pinchStart.mid.y);
          cam.minZoom = computeMinZoomToFit();
          cam.zoom = clamp(pinchStart.zoom * scale, cam.minZoom, cam.maxZoom);
          const after = screenToWorld(pinchStart.mid.x, pinchStart.mid.y);

          cam.x += (before.x - after.x);
          cam.y += (before.y - after.y);
          clampCameraToMap();

          if (down) down.multi = true;
        }
      }, { passive:true });

      canvas.addEventListener("pointerup", (e) => {
        const p = eventToCanvasXY(e);
        pointers.delete(e.pointerId);

        const wasTap = down && !down.moved && !down.multi;
        const recent = down && (performance.now() - down.time) < 650;
        if (wasTap && recent) firePickAtScreen(p.x, p.y);

        if (pointers.size === 1) {
          const only = Array.from(pointers.values())[0];
          isPanning = true;
          panStart = { x: only.x, y: only.y, camX: cam.x, camY: cam.y };
        } else {
          isPanning = false;
          pinchStart = null;
        }
        down = null;
      }, { passive:true });

      canvas.addEventListener("pointercancel", () => {
        pointers.clear();
        isPanning = false;
        pinchStart = null;
        down = null;
      }, { passive:true });

      (function quickInit(){
        resizeCanvas();
        cam.x = baseW / 2;
        cam.y = baseH / 2;
        cam.minZoom = computeMinZoomToFit();
        cam.zoom = Math.max(cam.zoom, cam.minZoom);
        clampCameraToMap();
      })();

      (async function init(){
        try {
          baseImg = await loadImage(baseMapSrc);
          baseW = baseImg.width; baseH = baseImg.height;
          cam.x = baseW/2; cam.y = baseH/2;
          cam.minZoom = computeMinZoomToFit();
          cam.zoom = Math.max(cam.zoom, cam.minZoom);
          clampCameraToMap();
        } catch (err) {
          console.error("City init failed:", err);
        }
      })();

      function drawBase(){
        const cx = canvas.width/2, cy = canvas.height/2;

        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = "#0f1220";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.setTransform(cam.zoom, 0, 0, cam.zoom, cx - cam.x*cam.zoom, cy - cam.y*cam.zoom);
        ctx.imageSmoothingEnabled = false;

        if (baseImg) ctx.drawImage(baseImg, 0, 0);
      }

      function drawPlacedBuildings() {
        if (!buildingsSystem) return;
        const placed = buildingsSystem.getAllPlaced?.() || [];
        if (!placed.length) return;

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        ctx.setTransform(cam.zoom, 0, 0, cam.zoom, cx - cam.x * cam.zoom, cy - cam.y * cam.zoom);
        ctx.imageSmoothingEnabled = false;

        for (const b of placed) {
          const plot = sceneState.plots.find(p => p.id === b.plotId);
          if (!plot) continue;

          const ax = plot.x + plot.w / 2;
          const ay = plot.y + plot.h;

          ctx.drawImage(
            b.img,
            Math.round(ax - b.w / 2),
            Math.round(ay - b.h),
            b.w,
            b.h
          );
        }
      }

      function drawPlotsOverlay(){
        ctx.setTransform(1,0,0,1,0,0);
        for (const p of sceneState.plots) {
          const a = worldToScreen(p.x, p.y);
          const b = worldToScreen(p.x+p.w, p.y+p.h);

          const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
          const w = Math.abs(b.x-a.x), h = Math.abs(b.y-a.y);

          const sel = p.id === sceneState.selectedPlotId;
          ctx.lineWidth = sel ? 3 : 2;
          ctx.strokeStyle = sel ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";
          ctx.strokeRect(x,y,w,h);

          if (sel) {
            ctx.fillStyle = "rgba(255,255,255,0.08)";
            ctx.fillRect(x,y,w,h);
          }
        }
      }

      return {
        setPlots(plots){ sceneState.plots = plots; },
        setBuildingsSystem(sys){ buildingsSystem = sys; },
        setOnPlotClick(fn){ onPlotClick = fn; },
        update(){ resizeCanvas(); cam.minZoom = computeMinZoomToFit(); clampCameraToMap(); },
        render(){ drawBase(); drawPlacedBuildings(); drawPlotsOverlay(); }
      };
    }

    // ===== DOM refs =====
    const canvas = document.getElementById("cityCanvas");

    const popup = document.getElementById("buildPopup");
    const buildTitle = document.getElementById("buildTitle");
    const buildGrid = document.getElementById("buildGrid");

    const barracksPanel = document.getElementById("barracksPanel");
    const settingsPanel = document.getElementById("settingsPanel");

    const timersToggle = document.getElementById("timersToggle");
    const timersStateText = document.getElementById("timersStateText");

    const r_food  = document.getElementById("r_food");
    const r_wood  = document.getElementById("r_wood");
    const r_stone = document.getElementById("r_stone");
    const r_ore   = document.getElementById("r_ore");
    const r_gold  = document.getElementById("r_gold");
    const r_th    = document.getElementById("r_th");
    const queueText = document.getElementById("queueText");
    const timerText = document.getElementById("timerText");

    const btnSettings = document.getElementById("btnSettings");
    const btnSave = document.getElementById("btnSave");
    const btnLoad = document.getElementById("btnLoad");
    const btnReset = document.getElementById("btnReset");

    // ===== Scene + Systems =====
    const inferred = inferMapSizeFromPlots(CITY_PLOTS, 512, 512);
    const scene = createCityScene(canvas, { baseMapSrc: BASE_MAP_SRC, initialMapSize: inferred });
    scene.setPlots(CITY_PLOTS);

    const buildings = createCityBuildingsSystem({ basePath: BUILDING_BASE_PATH });
    scene.setBuildingsSystem(buildings);

    // ===== Helpers =====
    function clampNum(v, a, b) {
      v = Number(v);
      if (!Number.isFinite(v)) return a;
      return Math.max(a, Math.min(b, v));
    }

function centerPanelOnScreen(panelEl){
  const pad = 12;

  const hud = document.getElementById("hudFixed");
  const topH = hud?.querySelector(".hudTop")?.getBoundingClientRect().height || 0;
  const midH = hud?.querySelector(".hudMid")?.getBoundingClientRect().height || 0;
  const botH = hud?.querySelector(".hudBottom")?.getBoundingClientRect().height || 0;

  const safeTop = pad + topH + midH;
  const safeBot = pad + botH;

  panelEl.style.display = "block";
  panelEl.style.visibility = "hidden";
  panelEl.style.left = "0px";
  panelEl.style.top  = "0px";

  const pw = panelEl.offsetWidth;
  const ph = panelEl.offsetHeight;

  panelEl.style.visibility = "visible";

  const x = Math.max(pad, Math.min(window.innerWidth  - pw - pad, (window.innerWidth  - pw)/2));
  const y = Math.max(safeTop, Math.min(window.innerHeight - ph - safeBot, (window.innerHeight - ph)/2));

  panelEl.style.left = `${x}px`;
  panelEl.style.top  = `${y}px`;
}


    function syncSettingsUI(){
      timersToggle.checked = !!state.settings.timersEnabled;
      timersStateText.textContent = state.settings.timersEnabled ? "ON" : "OFF";
      timerText.textContent = "Timers: " + (state.settings.timersEnabled ? "ON" : "OFF");
    }

    function fmt(n){ return Math.floor(n || 0).toLocaleString(); }

    function fmtDuration(ms){
      const totalSec = Math.max(0, Math.ceil(ms / 1000));
      const d = Math.floor(totalSec / 86400);
      const h = Math.floor((totalSec % 86400) / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      if (d > 0) return `${d}d ${h}h ${m}m`;
      if (h > 0) return `${h}h ${m}m`;
      if (m > 0) return `${m}m ${s}s`;
      return `${s}s`;
    }

    function hasBuilding(buildingId){
      const all = buildings.getAllPlaced?.() || [];
      return all.some(b => b.buildingId === buildingId);
    }

    function isResourceUnlocked(res) {
      if (res === "stone") return hasBuilding("quarry");
      if (res === "ore")   return hasBuilding("mine");
      return true;
    }

    function canAfford(cost) {
      if (!cost) return true;
      for (const k in cost) {
        const need = Number(cost[k] ?? 0);
        if (need <= 0) continue;
        if (!isResourceUnlocked(k)) return false;
        if ((state?.resources?.[k] ?? 0) < need) return false;
      }
      return true;
    }

    function fmtCostPretty(cost){
      if (!cost) return "?";
      const parts = [];
      if (cost.food)  parts.push(`F:${cost.food}`);
      if (cost.wood)  parts.push(`W:${cost.wood}`);
      if (cost.stone) parts.push(`S:${cost.stone}`);
      if (cost.ore)   parts.push(`O:${cost.ore}`);
      if (cost.gold)  parts.push(`G:${cost.gold}`);
      return parts.length ? parts.join("  ") : "?";
    }

    function syncLevelsFromPlaced() {
      const lv = (state.buildings.levels ||= {});
      // baseline keys
      lv.townhall = 0;
      lv.house = 0;
      lv.farm = 0;
      lv.lumber = 0;
      lv.quarry = 0;
      lv.mine = 0;
      lv.barracks = 0;
      lv.academy = 0;
      lv.commandcenter = 0;

      for (const plot of CITY_PLOTS) {
        const placed = buildings.getPlacedOnPlot?.(plot.id);
        if (!placed) continue;
        const key = placed.buildingId;
        if (Object.prototype.hasOwnProperty.call(lv, key)) lv[key] = placed.level ?? 1;
      }
      state.buildings.townhallLevel = lv.townhall || 0;
    }

    function getQueueInfoSafe() {
      return buildings.getBuildQueueInfo?.() || { active: 0, max: 2, full: false };
    }

    // ===== UI State =====
    let currentBuildPlot = null;
    let barracksTab = "train";

    function getStatusCompat(plotId){
      return buildings.getStatus?.(plotId) || null;
    }
    function canBuildBuildingCompat(buildingId){
      return buildings.canBuildBuilding?.(buildingId) ?? { ok:true };
    }
    function canUpgradePlotCompat(plotId){
      return buildings.canUpgradePlot?.(plotId) ?? { ok:true };
    }
    async function placeBuildingCompat(plotId, buildingId){
      return await buildings.placeBuildingOnPlot(plotId, buildingId, 1);
    }
    async function upgradePlotCompat(plotId){
      return await buildings.upgradePlot(plotId);
    }

    function renderBuildPopupForPlot(plot, { recenter=true } = {}){
      currentBuildPlot = plot;
      buildGrid.innerHTML = "";

      const existing = buildings.getPlacedOnPlot?.(plot.id);
      const st = getStatusCompat(plot.id);

      if (existing) {
        const lvl = existing.level ?? 1;
        const def = BUILDINGS[existing.buildingId];
        const name = def?.name || existing.buildingId;

        const constructing = !!st?.constructing;
        const upgrading = !!st?.upgrading;

        const chk = canUpgradePlotCompat(plot.id);
        const upgradeCost = def?.upgradeCost ? def.upgradeCost(lvl) : null;
        const affordable = canAfford(upgradeCost);

        const q = getQueueInfoSafe();
        const queueBlocked = state.settings.timersEnabled && q.full;

        const disabled =
          constructing || upgrading ||
          queueBlocked ||
          (!chk.ok || !affordable || !upgradeCost);

        const stateTag = constructing ? "Constructing" : upgrading ? "Upgrading" : "Occupied";
        buildTitle.textContent = `Plot: ${plot.id} (${stateTag})`;

        let timerLine = "";
        if (constructing) {
          timerLine = `<div class="upReason">Under construction… <b>${fmtDuration(st.buildRemainingMs)}</b> left</div>`;
        } else if (upgrading) {
          timerLine = `<div class="upReason">Upgrading to <b>Lv ${st.upgradingToLevel || (lvl+1)}</b>… <b>${fmtDuration(st.upgradeRemainingMs)}</b> left</div>`;
        }

        buildGrid.innerHTML = `
          <div class="upCard">
            <div class="upTitle">${name}</div>
            <div class="upRow"><span>Current Level</span><b>${lvl}</b></div>
            <div class="upRow"><span>Cost</span><span class="upCost">${fmtCostPretty(upgradeCost)}</span></div>

            <button class="upBtn" type="button" data-action="build-upgrade" ${disabled ? "disabled" : ""}>
              ${upgrading ? "Upgrading…" : `Upgrade → Lv ${lvl + 1}`}
            </button>

            ${timerLine}
            ${(!constructing && !upgrading && queueBlocked) ? `<div class="upReason">All ${q.max} builder queues are busy.</div>` : ""}
            ${(!constructing && !upgrading && !chk.ok) ? `<div class="upReason">${chk.reason}</div>` : ""}
            ${(!constructing && !upgrading && chk.ok && upgradeCost && !affordable) ? `<div class="upReason">Not enough resources</div>` : ""}
          </div>
        `;
      } else {
        buildTitle.textContent = `Plot: ${plot.id} (Build)`;

        const q = getQueueInfoSafe();
        const queueBlocked = state.settings.timersEnabled && q.full;

        const frag = document.createDocumentFragment();

        for (const bKey of Object.keys(BUILDINGS).filter(k => k !== "townhall")) {
          const def = BUILDINGS[bKey];
          const cost = def?.cost || null;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "buildBtn";
          btn.setAttribute("data-action", "build-place");
          btn.setAttribute("data-building-id", bKey);

          const line2 = cost ? fmtCostPretty(cost) : "";
          btn.textContent = (def?.name || bKey) + (line2 ? ("\n" + line2) : "");

          const gate = canBuildBuildingCompat(bKey);
          if (!gate.ok) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = gate.reason;
          } else if (cost && !canAfford(cost)) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = "Not enough resources";
          }

          if (queueBlocked) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = `All ${q.max} builder queues are busy.`;
          }

          frag.appendChild(btn);
        }

        buildGrid.appendChild(frag);
      }

      popup.style.display = "block";
      if (recenter) centerPanel(popup);
    }

    function fmtMMSS(ms) {
      const total = Math.max(0, Math.ceil(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function unlockedTiersForBarracksLevel(lvl) {
      const tiers = [];
      for (const tier of ["T1","T2","T3","T4"]) {
        if ((BARRACKS_TIER_UNLOCK?.[tier] ?? 999) <= lvl) tiers.push(tier);
      }
      return tiers;
    }

    function troopOptionsForBarracksLevel(barracksLevel) {
      const allowed = new Set(unlockedTiersForBarracksLevel(barracksLevel));
      return Object.values(TROOPS)
        .filter(t => allowed.has(t.tier))
        .map(t => ({ id: t.id, label: t.label ?? t.id }));
    }

    function getBarracksLevelSafe() {
      return Number(state?.buildings?.levels?.barracks || 0);
    }

    function findBarracksPlot(){
      return CITY_PLOTS.find(p => buildings.getPlacedOnPlot?.(p.id)?.buildingId === "barracks") || null;
    }

    function normalizeSlots(snap){
      let slots = snap?.slots ?? snap?.items ?? snap?.queue ?? snap?.queues?.barracks ?? snap?.queues;
      if (!Array.isArray(slots)) slots = slots ? Object.values(slots).flat() : [];
      return slots.map((s) => {
        if (s?.active) {
          const job = s.active;
          const now = Date.now();
          const totalMs = job.totalMs ?? Math.max(1, (job.endAt ?? now) - (job.startAt ?? now));
          const remainingMs = Math.max(0, (job.endAt ?? now) - now);
          return { status:"training", troopId:job.troopId, amount:job.amount, totalMs, remainingMs };
        }
        if (s?.status) return s;
        return { status:"idle" };
      });
    }

    function renderBarracksPanel({ recenter=true } = {}){
      const barracksLevel = getBarracksLevelSafe();
      try { syncBarracksSlots?.(barracksLevel); } catch {}

      const snap = getTrainingSnapshot?.("barracks") ?? {};
      const normalized = normalizeSlots(snap);
      const opts = troopOptionsForBarracksLevel(barracksLevel);

      const trainHtml = normalized.map((s, i) => {
        const isIdle = s.status === "idle" || !s.troopId;
        if (isIdle) {
          const options = opts.map(o => `<option value="${o.id}">${o.label}</option>`).join("");
          return `
            <div style="border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:12px;margin:10px 0;">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <b>Slot ${i+1}</b>
                <span style="opacity:.7">Idle</span>
              </div>

              <div style="display:flex;gap:8px;margin-top:10px;">
                <select data-slot="${i}" data-role="troop"
                  style="flex:1; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.12);
                  border-radius:12px; padding:10px;">
                  ${options || `<option value="">(No troops unlocked)</option>`}
                </select>

                <input data-slot="${i}" data-role="amt" type="number" min="1" value="1"
                  style="width:92px; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.12);
                  border-radius:12px; padding:10px;" />
              </div>

              <button type="button" data-action="bx-start" data-slot="${i}"
                style="margin-top:10px; width:100%; background:#2563eb; color:white; border:0;
                border-radius:12px; padding:12px; font-weight:900; cursor:pointer; touch-action:manipulation;">
                Train
              </button>
            </div>
          `;
        }

        const pct = s.totalMs ? Math.min(100, Math.max(0, 100 * (1 - s.remainingMs / s.totalMs))) : 0;
        return `
          <div style="border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:12px;margin:10px 0;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <b>Slot ${i+1}</b>
              <span style="opacity:.9">${s.troopId} × ${s.amount}</span>
            </div>

            <div style="margin-top:10px; height:10px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden;">
              <div style="height:100%; width:${pct}%; background:rgba(37,99,235,.95);"></div>
            </div>

            <div style="display:flex; justify-content:space-between; margin-top:8px; opacity:.85;">
              <span>${fmtMMSS(s.remainingMs)} left</span>
              <span>${Math.round(pct)}%</span>
            </div>

            <button type="button" data-action="bx-cancel" data-slot="${i}"
              style="margin-top:10px; width:100%; background:rgba(239,68,68,.95); color:white; border:0;
              border-radius:12px; padding:12px; font-weight:900; cursor:pointer; touch-action:manipulation;">
              Cancel
            </button>
          </div>
        `;
      }).join("");

      const barracksPlot = findBarracksPlot();
      const barracksPlaced = barracksPlot ? buildings.getPlacedOnPlot?.(barracksPlot.id) : null;

      let upgradeBlock = `<div style="opacity:.85">No barracks placed yet.</div>`;
      if (barracksPlaced && barracksPlot) {
        const lvl = barracksPlaced.level ?? 1;
        const chk = canUpgradePlotCompat(barracksPlot.id);
        const def = BUILDINGS?.barracks;
        const upgradeCost = def?.upgradeCost ? def.upgradeCost(lvl) : null;
        const affordable = canAfford(upgradeCost);

        const st = getStatusCompat(barracksPlot.id);
        const upgrading = !!st?.upgrading;
        const constructing = !!st?.constructing;

        const q = getQueueInfoSafe();
        const queueBlocked = state.settings.timersEnabled && q.full;

        const disabled = constructing || upgrading || queueBlocked || (!chk.ok || (upgradeCost && !affordable) || !upgradeCost);

        let timerLine = "";
        if (constructing) timerLine = `<div class="upReason">Under construction… <b>${fmtDuration(st.buildRemainingMs)}</b> left</div>`;
        if (upgrading) timerLine = `<div class="upReason">Upgrading… <b>${fmtDuration(st.upgradeRemainingMs)}</b> left</div>`;

        upgradeBlock = `
          <div class="upCard">
            <div class="upTitle">Barracks</div>
            <div class="upRow"><span>Current Level:</span> <b>${lvl}</b></div>
            <div class="upRow"><span>Cost:</span> <span class="upCost">${fmtCostPretty(upgradeCost)}</span></div>

            <button type="button" class="upBtn" data-action="bx-upgrade" ${disabled ? "disabled" : ""}>
              ${upgrading ? "Upgrading…" : `Upgrade → Lv ${lvl+1}`}
            </button>

            ${timerLine}
            ${(!constructing && !upgrading && queueBlocked) ? `<div class="upReason">All ${q.max} builder queues are busy.</div>` : ""}
            ${(!constructing && !upgrading && !chk.ok ? `<div class="upReason">${chk.reason}</div>` : "")}
            ${(!constructing && !upgrading && chk.ok && upgradeCost && !affordable ? `<div class="upReason">Not enough resources</div>` : "")}

            <div class="upHint">Tiers unlock: L1=T1, L5=T2, L10=T3, L15=T4</div>
          </div>
        `;
      }

      barracksPanel.innerHTML = `
        <div class="bxHeader">
          <div>
            <div style="font-size:14px;font-weight:900;">Barracks</div>
            <div style="opacity:.7;margin-top:2px;">L${barracksLevel}</div>
          </div>
          <button class="bxClose" type="button" data-action="bx-close">Close</button>
        </div>

        <div class="bxWrap">
          <div class="bxTabs">
            <button class="bxTab ${barracksTab==="train"?"active":""}" data-action="bx-tab" data-tab="train" type="button">Train</button>
            <button class="bxTab ${barracksTab==="upgrade"?"active":""}" data-action="bx-tab" data-tab="upgrade" type="button">Upgrade</button>
          </div>

          <div class="bxMain">
            <div style="display:${barracksTab==="train"?"block":"none"};">
              ${trainHtml || `<div style="opacity:.8">No slots found.</div>`}
              <div class="upHint">Tiers unlock: L1=T1, L5=T2, L10=T3, L15=T4</div>
            </div>

            <div style="display:${barracksTab==="upgrade"?"block":"none"};">
              ${upgradeBlock}
            </div>
          </div>
        </div>
      `;

      if (recenter) centerPanel(barracksPanel);
    }

    async function handleAction(action, el){
      if (action === "open-settings") {
        popup.style.display = "none";
        barracksPanel.style.display = "none";
        settingsPanel.style.display = "block";
        syncSettingsUI();
        centerPanel(settingsPanel);
        return;
      }
      if (action === "settings-close") { settingsPanel.style.display = "none"; return; }
      if (action === "timers-finish-now") {
        buildings.finishAllTimersNow?.();
        if (popup.style.display !== "none" && currentBuildPlot) renderBuildPopupForPlot(currentBuildPlot, { recenter:false });
        if (barracksPanel.style.display !== "none") renderBarracksPanel({ recenter:false });
        try { saveGame(); } catch {}
        return;
      }
      if (action === "build-close") { popup.style.display = "none"; return; }

      if (action === "build-upgrade") {
        const plot = currentBuildPlot;
        if (!plot) return;

        const st = getStatusCompat(plot.id);
        if (st?.constructing || st?.upgrading) return;

        const res = await upgradePlotCompat(plot.id);
        if (!res?.ok) { alert(res?.reason || "Upgrade failed"); return; }

        syncLevelsFromPlaced();
        renderBuildPopupForPlot(plot, { recenter:false });
        try { saveGame(); } catch {}
        return;
      }

      if (action === "build-place") {
        const plot = currentBuildPlot;
        if (!plot) return;

        const bKey = el.getAttribute("data-building-id");
        if (!bKey) return;

        const r = await placeBuildingCompat(plot.id, bKey);
        if (r && r.ok === false) alert(r.reason || "Could not build.");

        syncLevelsFromPlaced();
        popup.style.display = "none";
        try { saveGame(); } catch {}
        return;
      }

      if (action === "bx-close") { barracksPanel.style.display = "none"; return; }
      if (action === "bx-tab") {
        barracksTab = el.getAttribute("data-tab") || "train";
        renderBarracksPanel({ recenter:true });
        return;
      }

      if (action === "bx-start") {
        const barracksLevel = getBarracksLevelSafe();
        const slotIndex = Number(el.getAttribute("data-slot"));
        const troopSel = barracksPanel.querySelector(`select[data-slot="${slotIndex}"][data-role="troop"]`);
        const amtInp  = barracksPanel.querySelector(`input[data-slot="${slotIndex}"][data-role="amt"]`);
        const troopId = troopSel?.value;
        const amount = Math.max(1, Number(amtInp?.value || 1));
        if (!troopId) return alert("No troop selected / unlocked.");
        const res = startTrainingInSlot({ barracksLevel, slotIndex, troopId, amount });
        if (!res?.ok) alert(res?.reason || "Could not start training.");
        renderBarracksPanel({ recenter:false });
        return;
      }

      if (action === "bx-cancel") {
        const slotIndex = Number(el.getAttribute("data-slot"));
        if (!confirm("Cancel this training slot?")) return;
        const res = cancelTraining?.({ slotIndex, refundPercent: 0.5 });
        if (res && res.ok === false) alert(res.reason || "Could not cancel.");
        renderBarracksPanel({ recenter:false });
        return;
      }

      if (action === "bx-upgrade") {
        const barracksPlot = findBarracksPlot();
        if (!barracksPlot) return;

        const st = getStatusCompat(barracksPlot.id);
        if (st?.constructing || st?.upgrading) return;

        const r = await upgradePlotCompat(barracksPlot.id);
        if (r && r.ok === false) { alert(r.reason || "Upgrade failed."); return; }

        syncLevelsFromPlaced();
        renderBarracksPanel({ recenter:false });
        try { saveGame(); } catch {}
        return;
      }
    }

    // Delegated clicks for panel buttons
    document.getElementById("panels").addEventListener("pointerup", async (e) => {
      const btn = e.target?.closest?.("[data-action]");
      if (!btn) return;
      e.preventDefault();
      e.stopPropagation();
      const action = btn.getAttribute("data-action");
      await handleAction(action, btn);
    }, { passive:false });

    // Settings toggle
    syncSettingsUI();
    timersToggle.addEventListener("change", () => {
      state.settings.timersEnabled = !!timersToggle.checked;
      syncSettingsUI();

      if (!state.settings.timersEnabled) {
        buildings.finishAllTimersNow?.();
        if (popup.style.display !== "none" && currentBuildPlot) renderBuildPopupForPlot(currentBuildPlot, { recenter:false });
        if (barracksPanel.style.display !== "none") renderBarracksPanel({ recenter:false });
      }
      try { saveGame(); } catch {}
    });

    // Top HUD buttons
    btnSettings.addEventListener("pointerup", () => handleAction("open-settings"));
    btnSave.addEventListener("pointerup", () => saveGame());
    btnLoad.addEventListener("pointerup", () => loadGame());
    btnReset.addEventListener("pointerup", () => resetSave());

    // Plot click
    scene.setOnPlotClick((plot) => {
      if (!plot) return;
      if (settingsPanel.style.display !== "none") return;

      const existing = buildings.getPlacedOnPlot?.(plot.id);
      const isBarracks = existing?.buildingId === "barracks";

      if (isBarracks) {
        popup.style.display = "none";
        settingsPanel.style.display = "none";
        barracksTab = "train";
        barracksPanel.style.display = "block";
        renderBarracksPanel({ recenter:true });
        return;
      }

      barracksPanel.style.display = "none";
      settingsPanel.style.display = "none";
      renderBuildPopupForPlot(plot, { recenter:true });
    });

    // ===== Save / Load =====
    function buildSavePayload() {
      syncLevelsFromPlaced();
      const placed = [];

      for (const plot of CITY_PLOTS) {
        const p = buildings.getPlacedOnPlot?.(plot.id);
        if (!p) continue;
        placed.push({
          plotId: plot.id,
          buildingId: p.buildingId,
          level: p.level ?? 1,
          buildStartedAt: p.buildStartedAt ?? 0,
          buildEndAt: p.buildEndAt ?? 0,
          upgradeStartedAt: p.upgradeStartedAt ?? 0,
          upgradeEndAt: p.upgradeEndAt ?? 0,
          upgradingToLevel: p.upgradingToLevel ?? 0,
        });
      }

      return {
        v: 1,
        ts: Date.now(),
        resources: { ...state.resources },
        levels: { ...state.buildings.levels },
        settings: { ...state.settings },
        placed,
      };
    }

    function saveGame() {
      const payload = buildSavePayload();
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return console.warn("No save found.");
      sessionStorage.setItem(PENDING_KEY, raw);
      location.reload();
    }

    function resetSave() {
      localStorage.removeItem(SAVE_KEY);
      sessionStorage.removeItem(PENDING_KEY);
      location.reload();
    }

    async function applyPayload(data) {
      if (!data || typeof data !== "object") return false;

      if (data.resources) {
        state.resources.food  = Number(data.resources.food  ?? 0);
        state.resources.wood  = Number(data.resources.wood  ?? 0);
        state.resources.stone = Number(data.resources.stone ?? 0);
        state.resources.ore   = Number(data.resources.ore   ?? 0);
        state.resources.gold  = Number(data.resources.gold  ?? 0);
      }

      if (data.settings && typeof data.settings === "object") {
        state.settings.timersEnabled = (typeof data.settings.timersEnabled === "boolean")
          ? data.settings.timersEnabled
          : state.settings.timersEnabled;
        syncSettingsUI();
      }

      if (Array.isArray(data.placed)) {
        await buildings.hydrateFromSave?.(data.placed);
      } else {
        buildings.resetAllPlaced?.();
      }

      await buildings.ensureTownhall?.();
      syncLevelsFromPlaced();
      return true;
    }

    (async function bootLoad() {
      const pending = sessionStorage.getItem(PENDING_KEY);
      if (!pending) {
        await buildings.ensureTownhall?.();
        syncLevelsFromPlaced();
        return;
      }

      sessionStorage.removeItem(PENDING_KEY);
      try {
        const data = JSON.parse(pending);
        await applyPayload(data);
      } catch (e) {
        console.error("Pending load failed:", e);
        await buildings.ensureTownhall?.();
        syncLevelsFromPlaced();
      }
    })();

    // Autosave
    setInterval(() => { try { saveGame(); } catch {} }, 10000);

    // ===== Fixed HUD refresh =====
    function refreshHud(){
      const p = getProductionPerSecond();
      // show totals; if you want rates later we can add a long-press tooltip or a details panel
      r_food.textContent  = `🍖 ${fmt(state.resources.food)}`;
      r_wood.textContent  = `🪵 ${fmt(state.resources.wood)}`;
      r_stone.textContent = `🪨 ${fmt(state.resources.stone)}`;
      r_ore.textContent   = `⛏️ ${fmt(state.resources.ore)}`;
      r_gold.textContent  = `🪙 ${fmt(state.resources.gold)}`;
      r_th.textContent    = `🏛️ TH ${state.buildings?.levels?.townhall || 0}`;

      const q = getQueueInfoSafe();
      queueText.textContent = `Queue: ${q.active || 0}/${q.max || 2}`;
      timerText.textContent = "Timers: " + (state.settings.timersEnabled ? "ON" : "OFF");

      // optional: could show rates somewhere later (p.food etc)
      void p;
    }

    // ===== Main loop =====
    let lastT = 0;
    function frame(t){
      const dt = lastT ? (t - lastT) / 1000 : 0;
      lastT = t;

      scene.update();
      scene.render();

      // economy tick
      updateEconomy(dt);

      // training tick
      try { processTrainingQueues?.(); } catch {}

      // build/upgrade timers tick
      try {
        const changed = buildings.tick?.() || false;
        if (changed) {
          syncLevelsFromPlaced();
          try { saveGame(); } catch {}
        }
      } catch {}

      // update open panels (timer countdowns)
      if (popup.style.display !== "none" && currentBuildPlot) renderBuildPopupForPlot(currentBuildPlot, { recenter:false });
      if (barracksPanel.style.display !== "none") renderBarracksPanel({ recenter:false });

      refreshHud();
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // keep centered panels centered on resize
    window.addEventListener("resize", () => {
      if (popup.style.display !== "none") centerPanel(popup);
      if (barracksPanel.style.display !== "none") centerPanel(barracksPanel);
      if (settingsPanel.style.display !== "none") centerPanel(settingsPanel);
    });
  </script>
</body>
</html>
  