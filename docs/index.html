<!-- docs/index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Empire</title>

  <style>
    html, body { height:100%; margin:0; background:#0f1220; overflow:hidden; }
    canvas{
      position:fixed; inset:0; width:100%; height:100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action:none;
      display:block;
    }

    #uiOverlay{
      position:fixed;
      left:0; top:0;
      width:0; height:0;
      overflow:hidden;
      pointer-events:none;
      z-index:1000;
    }

    #resourceBar{
      position:absolute;
      left:0; top:0; right:0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;

      padding:12px 14px;
      background:linear-gradient(180deg, rgba(10,14,30,.92), rgba(0,0,0,.55));
      color:#eaf0ff;
      font:14px/1.15 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      border-bottom:1px solid rgba(255,255,255,.12);

      pointer-events:auto;
      user-select:none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);

      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 -1px 0 rgba(255,255,255,.06);
      touch-action: manipulation;
    }

    #resourceLeft{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
    }

    .resItem{
      display:flex;
      gap:8px;
      align-items:baseline;
      padding:6px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      white-space:nowrap;
    }

    .resItem b{ font-weight:900; letter-spacing:.2px; }
    .resItem span{ opacity:.8; font-size:12px; margin-left:2px; }

    #resourceRight{ display:flex; gap:10px; align-items:center; }

    #resourceRight button{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      color:#eaf0ff;
      cursor:pointer;
      font:13px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      touch-action: manipulation;
    }

    #resourceRight button:hover{
      background:rgba(255,255,255,.14);
      border-color:rgba(255,255,255,.22);
      transform: translateY(-1px);
    }
    #resourceRight button:active{ transform: translateY(0px); }

    #floatingPanels{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    .uiPanel{
      position:absolute;
      min-width:280px;
      max-width:420px;
      background:rgba(0,0,0,.78);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      pointer-events:auto;
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      touch-action: manipulation;
    }
    .uiPanel, .uiPanel * { pointer-events:auto; }
    .uiPanel button, .uiPanel select, .uiPanel input { touch-action: manipulation; }

    #buildPopup{ display:none; }
    #buildTitle{ font-weight:900; margin-bottom:10px; font-size:14px; }
    #buildGrid{ display:block; }
    .buildBtn{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      text-align:left;
      white-space:pre-line;
      transition: background 120ms ease, transform 120ms ease;
      width:100%;
      touch-action: manipulation;
    }
    .buildBtn:hover{ background:rgba(255,255,255,.16); transform: translateY(-1px); }
    .buildBtn:active{ transform: translateY(0px); }

    .row{ display:flex; justify-content:flex-end; gap:10px; margin-top:12px; }
    .closeBtn{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      touch-action: manipulation;
    }
    .closeBtn:hover{ background:rgba(255,255,255,.16); }

    #barracksPanel{ display:none; width:420px; max-height:70vh; overflow:auto; }

    .upCard{
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 14px;
      color: #e5e7eb;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
    }

    .upTitle{
      font-size: 18px;
      font-weight: 900;
      letter-spacing: .2px;
      margin-bottom: 8px;
      color:#ffffff;
    }

    .upRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size: 14px;
      margin: 6px 0;
      opacity: .95;
    }
    .upRow b{ font-weight: 900; }
    .upCost{ font-weight: 900; letter-spacing: .3px; }

    .upHint{
      margin-top: 10px;
      font-size: 12px;
      opacity: .78;
      line-height: 1.3;
    }

    .upBtn{
      margin-top: 12px;
      width: 100%;
      border: 0;
      border-radius: 14px;
      padding: 14px 14px;
      font-weight: 900;
      font-size: 16px;
      cursor: pointer;
      background: #22c55e;
      color: #06210f;
      box-shadow: 0 12px 26px rgba(34,197,94,.25);
      touch-action: manipulation;
    }

    .upBtn:hover{ filter: brightness(1.05); }
    .upBtn:active{ transform: translateY(1px); }

    .upBtn[disabled]{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.45);
      box-shadow: none;
      cursor: not-allowed;
    }

    .upReason{
      margin-top: 10px;
      font-size: 12px;
      opacity: .85;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
    }

    .bxHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
    .bxClose{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      touch-action: manipulation;
    }
    .bxClose:hover{ background:rgba(255,255,255,.16); }
    .bxWrap{ display:flex; gap:12px; }
    .bxTabs{
      width:120px;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-right:10px;
      border-right:1px solid rgba(255,255,255,.10);
    }
    .bxTab{
      width:100%;
      text-align:left;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      cursor:pointer;
      font-weight:900;
      touch-action: manipulation;
    }
    .bxTab:hover{ background:rgba(255,255,255,.10); }
    .bxTab.active{
      background:rgba(34,197,94,.18);
      border-color:rgba(34,197,94,.35);
      color:#eafff2;
    }
    .bxMain{ flex:1; min-width:0; }

    /* Settings Panel */
    #settingsPanel{ display:none; width:380px; }
    .setRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      margin-top:10px;
    }
    .setRow label{ display:flex; align-items:center; gap:10px; font-weight:900; }
    .setHint{ margin-top:10px; font-size:12px; opacity:.8; line-height:1.3; }
    .neutralBtn{
      margin-top:10px;
      width:100%;
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:12px 12px;
      font-weight:900;
      cursor:pointer;
      background:rgba(255,255,255,.10);
      color:#fff;
      touch-action:manipulation;
    }
    .neutralBtn:hover{ background:rgba(255,255,255,.16); }
  </style>

  <link rel="icon" href="./favicon.ico">
</head>

<body>
  <canvas id="cityCanvas"></canvas>

  <div id="uiOverlay">
    <div id="resourceBar">
      <div id="resourceLeft"></div>
      <div id="resourceRight">
        <button id="btnSettings" type="button" data-action="open-settings">Settings</button>
        <button id="btnSave" type="button">Save</button>
        <button id="btnLoad" type="button">Load</button>
        <button id="btnReset" type="button">Reset</button>
      </div>
    </div>

    <div id="floatingPanels">
      <div id="buildPopup" class="uiPanel">
        <div id="buildTitle">Build</div>
        <div id="buildGrid"></div>
        <div class="row">
          <button id="buildClose" class="closeBtn" type="button" data-action="build-close">Close</button>
        </div>
      </div>

      <div id="barracksPanel" class="uiPanel"></div>

      <div id="settingsPanel" class="uiPanel">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
          <div style="font-weight:900; font-size:14px;">Settings</div>
          <button class="closeBtn" type="button" data-action="settings-close">Close</button>
        </div>

        <div class="setRow">
          <label>
            <input id="timersToggle" type="checkbox" />
            Build/Upgrade Timers
          </label>
          <span id="timersStateText" style="opacity:.85; font-weight:900;">ON</span>
        </div>

        <button class="neutralBtn" type="button" data-action="timers-finish-now">
          Finish any active timers now
        </button>

        <div class="setHint">
          Turn timers <b>OFF</b> to test instantly. If you toggle OFF while anything is in progress, it will auto-finish so you don’t get stuck.
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { CITY_PLOTS } from "./js/plots.city.js";
    import { BUILDINGS } from "./js/data/buildingCatalog.js";
    import { createcitybuildingsSystem } from "./js/systems/cityBuildings.js";
    import { state } from "./js/state.js";
    import { updateEconomy, getProductionPerSecond } from "./js/systems/cityEconomy.js";
    import { processTrainingQueues } from "./js/systems/trainingsystems.js";
    import { getTrainingSnapshot, startTrainingInSlot, cancelTraining, syncBarracksSlots } from "./js/systems/trainingsystems.js";
    import { TROOPS, BARRACKS_TIER_UNLOCK } from "./js/data/troopsCatalog.js";

    const BASE_MAP_SRC = "./assets/maps/city/city_tilemap_base.png";
    const BUILDING_BASE_PATH = "./assets/city";
    const SAVE_KEY = "empire_city_save_v1";
    const PENDING_KEY = "EMPIRE_PENDING_LOAD";

    state.settings ??= {};
    if (typeof state.settings.timersEnabled !== "boolean") state.settings.timersEnabled = true;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    // ✅ NEW: infer map bounds from plots so cam math (clicking) works immediately
    function inferMapSizeFromPlots(plots, fallbackW = 512, fallbackH = 512){
      if (!Array.isArray(plots) || !plots.length) return { w: fallbackW, h: fallbackH };
      let maxX = 0, maxY = 0;
      for (const p of plots) {
        const x2 = (Number(p.x) || 0) + (Number(p.w) || 0);
        const y2 = (Number(p.y) || 0) + (Number(p.h) || 0);
        if (x2 > maxX) maxX = x2;
        if (y2 > maxY) maxY = y2;
      }
      // guard against tiny/zero maps
      return { w: Math.max(fallbackW, Math.ceil(maxX)), h: Math.max(fallbackH, Math.ceil(maxY)) };
    }

    function createCityScene(canvas, { baseMapSrc, initialMapSize }) {
      const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });
      ctx.imageSmoothingEnabled = false;

      let buildingsSystem = null;
      let onPlotClick = null;

      let baseImg = null;

      // ✅ initialize to plot-derived size so clicks work instantly
      let baseW = initialMapSize?.w ?? 512;
      let baseH = initialMapSize?.h ?? 512;

      const cam = { x: baseW/2, y: baseH/2, zoom: 2, minZoom: 1, maxZoom: 6 };
      const sceneState = { plots: [], selectedPlotId: null };

      function resizeCanvas(){
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const r = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(r.width * dpr));
        const h = Math.max(1, Math.floor(r.height * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
          ctx.setTransform(1,0,0,1,0,0);
          ctx.imageSmoothingEnabled = false;
        }
      }

      function worldToScreen(wx, wy){
        const cx = canvas.width/2, cy = canvas.height/2;
        return { x:(wx-cam.x)*cam.zoom+cx, y:(wy-cam.y)*cam.zoom+cy };
      }
      function screenToWorld(sx, sy){
        const cx = canvas.width/2, cy = canvas.height/2;
        return { x:(sx-cx)/cam.zoom+cam.x, y:(sy-cy)/cam.zoom+cam.y };
      }

      function clampCameraToMap(){
        const viewW = canvas.width / cam.zoom;
        const viewH = canvas.height / cam.zoom;

        if (viewW >= baseW) cam.x = baseW / 2;
        else cam.x = clamp(cam.x, viewW/2, baseW - viewW/2);

        if (viewH >= baseH) cam.y = baseH / 2;
        else cam.y = clamp(cam.y, viewH/2, baseH - viewH/2);
      }

      function computeMinZoomToFit(){
        const zX = canvas.width / baseW;
        const zY = canvas.height / baseH;
        return Math.max(zX, zY);
      }

      function zoomAt(delta, sx, sy){
        const before = screenToWorld(sx, sy);
        cam.minZoom = computeMinZoomToFit();
        cam.zoom = clamp(cam.zoom * delta, cam.minZoom, cam.maxZoom);
        const after = screenToWorld(sx, sy);
        cam.x += (before.x - after.x);
        cam.y += (before.y - after.y);
        clampCameraToMap();
      }

      function eventToCanvasXY(e){
        const rect = canvas.getBoundingClientRect();
        return {
          x: (e.clientX - rect.left) * (canvas.width / rect.width),
          y: (e.clientY - rect.top)  * (canvas.height / rect.height)
        };
      }

      function pointInRect(px, py, r){
        return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
      }
      function pickPlot(wx, wy){
        for (let i = sceneState.plots.length - 1; i >= 0; i--) {
          const p = sceneState.plots[i];
          if (pointInRect(wx, wy, p)) return p;
        }
        return null;
      }

      function firePickAtScreen(sx, sy){
        const w = screenToWorld(sx, sy);
        const hit = pickPlot(w.x, w.y);
        sceneState.selectedPlotId = hit ? hit.id : null;

        if (hit && typeof onPlotClick === "function") {
          const anchorW = { x: hit.x + hit.w/2, y: hit.y + hit.h };
          const anchorS = worldToScreen(anchorW.x, anchorW.y);
          onPlotClick(hit, sx, sy, anchorW, anchorS);
        }
      }

      // Pointer pan/pinch/tap
      const pointers = new Map();
      let isPanning = false;
      let panStart = { x:0, y:0, camX:0, camY:0 };
      let down = null;
      let pinchStart = null;
      const TAP_MOVE_PX = 10;
      const dist = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
      const mid  = (a,b)=>({ x:(a.x+b.x)/2, y:(a.y+b.y)/2 });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const p = eventToCanvasXY(e);
        const factor = e.deltaY < 0 ? 1.12 : 1/1.12;
        zoomAt(factor, p.x, p.y);
      }, { passive:false });

      canvas.addEventListener("pointerdown", (e) => {
        canvas.setPointerCapture(e.pointerId);
        const p = eventToCanvasXY(e);
        pointers.set(e.pointerId, p);

        if (pointers.size === 1) {
          isPanning = true;
          panStart = { x:p.x, y:p.y, camX:cam.x, camY:cam.y };
          down = { x:p.x, y:p.y, time:performance.now(), moved:false, multi:false };
        } else if (pointers.size === 2) {
          const [a,b] = Array.from(pointers.values());
          pinchStart = { dist: dist(a,b), zoom: cam.zoom, mid: mid(a,b) };
          if (down) down.multi = true;
          isPanning = false;
        } else {
          if (down) down.multi = true;
          isPanning = false;
        }
      }, { passive:true });

      canvas.addEventListener("pointermove", (e) => {
        if (!pointers.has(e.pointerId)) return;
        const p = eventToCanvasXY(e);
        pointers.set(e.pointerId, p);

        if (pointers.size === 1 && isPanning) {
          cam.x = panStart.camX - (p.x - panStart.x) / cam.zoom;
          cam.y = panStart.camY - (p.y - panStart.y) / cam.zoom;
          clampCameraToMap();
          if (down && !down.moved && Math.hypot(p.x-down.x, p.y-down.y) > TAP_MOVE_PX) down.moved = true;
        } else if (pointers.size === 2 && pinchStart) {
          const [a,b] = Array.from(pointers.values());
          const d = dist(a,b);
          const scale = pinchStart.dist ? (d / pinchStart.dist) : 1;

          const before = screenToWorld(pinchStart.mid.x, pinchStart.mid.y);
          cam.minZoom = computeMinZoomToFit();
          cam.zoom = clamp(pinchStart.zoom * scale, cam.minZoom, cam.maxZoom);
          const after = screenToWorld(pinchStart.mid.x, pinchStart.mid.y);

          cam.x += (before.x - after.x);
          cam.y += (before.y - after.y);
          clampCameraToMap();

          if (down) down.multi = true;
        }
      }, { passive:true });

      canvas.addEventListener("pointerup", (e) => {
        const p = eventToCanvasXY(e);
        pointers.delete(e.pointerId);

        const wasTap = down && !down.moved && !down.multi;
        const recent = down && (performance.now() - down.time) < 650;
        if (wasTap && recent) firePickAtScreen(p.x, p.y);

        if (pointers.size === 1) {
          const only = Array.from(pointers.values())[0];
          isPanning = true;
          panStart = { x: only.x, y: only.y, camX: cam.x, camY: cam.y };
        } else {
          isPanning = false;
          pinchStart = null;
        }
        down = null;
      }, { passive:true });

      canvas.addEventListener("pointercancel", (e) => {
        pointers.delete(e.pointerId);
        isPanning = false;
        pinchStart = null;
        down = null;
      }, { passive:true });

      // ✅ run a “quick init” so cam is valid before image finishes loading
      (function quickInit(){
        resizeCanvas();
        cam.x = baseW / 2;
        cam.y = baseH / 2;
        cam.minZoom = computeMinZoomToFit();
        cam.zoom = Math.max(cam.zoom, cam.minZoom);
        clampCameraToMap();
      })();

      // load base map in background and sync to image size when available
      (async function init(){
        try {
          baseImg = await loadImage(baseMapSrc);
          baseW = baseImg.width; baseH = baseImg.height;

          cam.x = baseW/2; cam.y = baseH/2;
          cam.minZoom = computeMinZoomToFit();
          cam.zoom = Math.max(cam.zoom, cam.minZoom);
          clampCameraToMap();
        } catch (err) {
          console.error("City init failed:", err);
        }
      })();

      function drawBase(){
        const cx = canvas.width/2, cy = canvas.height/2;

        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = "#0f1220";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.setTransform(cam.zoom, 0, 0, cam.zoom, cx - cam.x*cam.zoom, cy - cam.y*cam.zoom);
        ctx.imageSmoothingEnabled = false;

        if (baseImg) ctx.drawImage(baseImg, 0, 0);
      }

      function drawPlacedBuildings() {
        if (!buildingsSystem) return;
        const placed = buildingsSystem.getAllPlaced?.() || [];
        if (!placed.length) return;

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        ctx.setTransform(cam.zoom, 0, 0, cam.zoom, cx - cam.x * cam.zoom, cy - cam.y * cam.zoom);
        ctx.imageSmoothingEnabled = false;

        for (const b of placed) {
          const plot = sceneState.plots.find(p => p.id === b.plotId);
          if (!plot) continue;

          const ax = plot.x + plot.w / 2;
          const ay = plot.y + plot.h;

          ctx.drawImage(
            b.img,
            Math.round(ax - b.w / 2),
            Math.round(ay - b.h),
            b.w,
            b.h
          );
        }
      }

      function drawPlotsOverlay(){
        ctx.setTransform(1,0,0,1,0,0);

        for (const p of sceneState.plots) {
          const a = worldToScreen(p.x, p.y);
          const b = worldToScreen(p.x+p.w, p.y+p.h);

          const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
          const w = Math.abs(b.x-a.x), h = Math.abs(b.y-a.y);

          const sel = p.id === sceneState.selectedPlotId;
          ctx.lineWidth = sel ? 3 : 2;
          ctx.strokeStyle = sel ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";
          ctx.strokeRect(x,y,w,h);

          if (sel) {
            ctx.fillStyle = "rgba(255,255,255,0.08)";
            ctx.fillRect(x,y,w,h);
          }
        }
      }

      return {
        setPlots(plots){ sceneState.plots = plots; },
        setBuildingsSystem(sys){ buildingsSystem = sys; },
        setOnPlotClick(fn){ onPlotClick = fn; },

        update(){ resizeCanvas(); cam.minZoom = computeMinZoomToFit(); clampCameraToMap(); },
        render(){ drawBase(); drawPlacedBuildings(); drawPlotsOverlay(); },

        worldToScreen,
        getMapWidth(){ return baseW; },
        getMapHeight(){ return baseH; },
      };
    }

    const canvas = document.getElementById("cityCanvas");

    // ✅ pass plot-inferred size into the scene
    const inferred = inferMapSizeFromPlots(CITY_PLOTS, 512, 512);
    const scene = createCityScene(canvas, { baseMapSrc: BASE_MAP_SRC, initialMapSize: inferred });
    scene.setPlots(CITY_PLOTS);

    const buildings = createcitybuildingsSystem({ basePath: BUILDING_BASE_PATH });
    scene.setBuildingsSystem(buildings);

    const uiOverlay = document.getElementById("uiOverlay");
    const resourceBar = document.getElementById("resourceBar");
    const resourceLeft = document.getElementById("resourceLeft");

    const popup = document.getElementById("buildPopup");
    const buildTitle = document.getElementById("buildTitle");
    const buildGrid = document.getElementById("buildGrid");
   

    const barracksPanel = document.getElementById("barracksPanel");
    const settingsPanel = document.getElementById("settingsPanel");
function isPanelVisible(el){
  return !!el && getComputedStyle(el).display !== "none";
}

// Force initial inline state so resize/devtools doesn’t “recenter” hidden panels
popup.style.display = "none";
barracksPanel.style.display = "none";
settingsPanel.style.display = "none";

    const timersToggle = document.getElementById("timersToggle");
    const timersStateText = document.getElementById("timersStateText");

    let currentBuildPlot = null;
    let barracksTab = "train";

    function clampNum(v, a, b) {
      v = Number(v);
      if (!Number.isFinite(v)) return a;
      return Math.max(a, Math.min(b, v));
    }

    function syncSettingsUI(){
      timersToggle.checked = !!state.settings.timersEnabled;
      timersStateText.textContent = state.settings.timersEnabled ? "ON" : "OFF";
      timersStateText.style.opacity = state.settings.timersEnabled ? "0.9" : "0.8";
    }
    syncSettingsUI();

    timersToggle.addEventListener("change", () => {
      state.settings.timersEnabled = !!timersToggle.checked;
      syncSettingsUI();

      if (!state.settings.timersEnabled) {
        buildings.finishAllTimersNow?.();
        if (popup.style.display !== "none" && currentBuildPlot) renderBuildPopupForPlot(currentBuildPlot, { recenter:false });
        if (barracksPanel.style.display !== "none") renderBarracksPanel({ recenter:false });
      }

      try { saveGame(); } catch {}
    });

    function getMapSizeSafe(){
      const w = (typeof scene.getMapWidth === "function") ? scene.getMapWidth() : 512;
      const h = (typeof scene.getMapHeight === "function") ? scene.getMapHeight() : 512;
      return { w, h };
    }

    function worldToScreenSafe(wx, wy){
      if (typeof scene.worldToScreen === "function") return scene.worldToScreen(wx, wy);
      return { x: wx, y: wy };
    }

    function canvasPxToCssPage(canvasPxX, canvasPxY){
      const r = canvas.getBoundingClientRect();
      return {
        x: r.left + (canvasPxX / canvas.width) * r.width,
        y: r.top  + (canvasPxY / canvas.height) * r.height
      };
    }

    function updateUiOverlayRect(){
      const { w: mapW, h: mapH } = getMapSizeSafe();
      const a = worldToScreenSafe(0, 0);
      const b = worldToScreenSafe(mapW, mapH);
      const A = canvasPxToCssPage(a.x, a.y);
      const B = canvasPxToCssPage(b.x, b.y);

      const left   = Math.min(A.x, B.x);
      const top    = Math.min(A.y, B.y);
      const right  = Math.max(A.x, B.x);
      const bottom = Math.max(A.y, B.y);

      uiOverlay.style.left = `${left}px`;
      uiOverlay.style.top = `${top}px`;
      uiOverlay.style.width = `${right - left}px`;
      uiOverlay.style.height = `${bottom - top}px`;
    }

    function centerPanelOnScreen(panelEl){
      const r = canvas.getBoundingClientRect();
      const overlayRect = uiOverlay.getBoundingClientRect();

      panelEl.style.display = "block";
      panelEl.style.visibility = "hidden";
      panelEl.style.left = "0px";
      panelEl.style.top  = "0px";

      const pw = panelEl.offsetWidth;
      const ph = panelEl.offsetHeight;

      panelEl.style.visibility = "visible";

      const targetPageX = r.left + r.width / 2;
      const targetPageY = r.top  + r.height / 2;

      const localX = targetPageX - overlayRect.left - pw / 2;
      const localY = targetPageY - overlayRect.top  - ph / 2;

      const pad = 12;
      const barH = resourceBar.offsetHeight || 64;

      const x = clampNum(localX, pad, Math.max(pad, overlayRect.width - pw - pad));
      const y = clampNum(localY, pad + barH, Math.max(pad + barH, overlayRect.height - ph - pad));

      panelEl.style.left = `${x}px`;
      panelEl.style.top  = `${y}px`;
    }

    // iOS ghost-tap guard: prevent plot taps right after UI taps
    let lastUiActionAt = 0;
    function markUiAction(){ lastUiActionAt = performance.now(); }
    function uiJustHappened(ms = 450){ return (performance.now() - lastUiActionAt) < ms; }
    let lastDelegatedFire = 0;

    function isUiTargetEvent(e){
      return !!e.target?.closest?.("#resourceBar, .uiPanel");
    }

    uiOverlay.addEventListener("pointerdown", (e) => {
      if (!isUiTargetEvent(e)) return;
      markUiAction();
      e.stopPropagation();
    }, { capture:true, passive:true });

    uiOverlay.addEventListener("pointerup", async (e) => {
      if (!isUiTargetEvent(e)) return;

      const now = performance.now();
      if (now - lastDelegatedFire < 250) return;
      lastDelegatedFire = now;

      markUiAction();
      e.preventDefault();
      e.stopPropagation();

      const btn = e.target?.closest?.("[data-action]");
      if (!btn) return;

      const action = btn.getAttribute("data-action");
      await handleUiAction(action, btn);
    }, { capture:true, passive:false });

    function fmtCost(cost) {
      if (!cost) return "";
      const parts = [];
      if (cost.food)  parts.push(`F:${cost.food}`);
      if (cost.wood)  parts.push(`W:${cost.wood}`);
      if (cost.stone) parts.push(`S:${cost.stone}`);
      if (cost.ore)   parts.push(`O:${cost.ore}`);
      if (cost.gold)  parts.push(`G:${cost.gold}`);
      return parts.length ? parts.join(" ") : "";
    }
    function fmtCostPretty(cost){
      if (!cost) return "?";
      const parts = [];
      if (cost.food)  parts.push(`F:${cost.food}`);
      if (cost.wood)  parts.push(`W:${cost.wood}`);
      if (cost.stone) parts.push(`S:${cost.stone}`);
      if (cost.ore)   parts.push(`O:${cost.ore}`);
      if (cost.gold)  parts.push(`G:${cost.gold}`);
      return parts.length ? parts.join("  ") : "?";
    }

    function isResourceUnlocked(res) {
      if (res === "stone") return !!buildings.getByBuildingId?.("quarry");
      if (res === "ore")   return !!buildings.getByBuildingId?.("mine");
      return true;
    }

    function canAfford(cost) {
      if (!cost) return true;
      for (const k in cost) {
        const need = Number(cost[k] ?? 0);
        if (need <= 0) continue;
        if (!isResourceUnlocked(k)) return false;
        if ((state?.resources?.[k] ?? 0) < need) return false;
      }
      return true;
    }

    function fmtDuration(ms){
      const totalSec = Math.max(0, Math.ceil(ms / 1000));
      const d = Math.floor(totalSec / 86400);
      const h = Math.floor((totalSec % 86400) / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      if (d > 0) return `${d}d ${h}h ${m}m`;
      if (h > 0) return `${h}h ${m}m`;
      if (m > 0) return `${m}m ${s}s`;
      return `${s}s`;
    }

    function syncLevelsFromPlaced() {
      const lv = (state.buildings.levels ||= {});
      lv.townhall = 0;
      lv.house = 0;
      lv.farm = 0;
      lv.lumber = 0;
      lv.quarry = 0;
      lv.mine = 0;
      lv.barracks = 0;
      lv.academy = 0;
      lv.commandcenter = 0;

      for (const plot of CITY_PLOTS) {
        const placed = buildings.getPlacedOnPlot?.(plot.id);
        if (!placed) continue;
        const key = placed.buildingId;
        if (Object.prototype.hasOwnProperty.call(lv, key)) lv[key] = placed.level ?? 1;
      }
      state.buildings.townhallLevel = lv.townhall || 0;
    }

    function getStatusCompat(plotId){
      return buildings.getStatus?.(plotId) || null;
    }

    function canBuildBuildingCompat(buildingId){
      return buildings.canBuildBuilding?.(buildingId) ?? { ok:true };
    }

    function canUpgradePlotCompat(plotId){
      return buildings.canUpgradePlot?.(plotId) ?? { ok:true };
    }

    async function placeBuildingCompat(plotId, buildingId){
      return await buildings.placeBuildingOnPlot(plotId, buildingId, 1);
    }

    async function upgradePlotCompat(plotId){
      return await buildings.upgradePlot(plotId);
    }

function getQueueInfoSafe() {
  return buildings.getBuildQueueInfo?.() || { active: 0, max: 2, full: false };
}

    function renderBuildPopupForPlot(plot, { recenter=true } = {}){
      currentBuildPlot = plot;
      const existing = buildings.getPlacedOnPlot?.(plot.id);
      buildGrid.innerHTML = "";

      const st = getStatusCompat(plot.id);

      if (existing) {
        const lvl = existing.level ?? 1;
        const def = BUILDINGS[existing.buildingId];
        const name = def?.name || existing.buildingId;

        const constructing = !!st?.constructing;
        const upgrading = !!st?.upgrading;

        const chk = canUpgradePlotCompat(plot.id);
        const upgradeCost = def?.upgradeCost ? def.upgradeCost(lvl) : null;
        const affordable = canAfford(upgradeCost);

        const q = getQueueInfoSafe();
        const queueBlocked = state.settings.timersEnabled && q.full;
        const disabled = constructing || upgrading || queueBlocked || (!chk.ok || !affordable || !upgradeCost);


        const stateTag = constructing ? "Constructing" : upgrading ? "Upgrading" : "Occupied";
        buildTitle.textContent = `Plot: ${plot.id} (${stateTag})`;

        let timerLine = "";
        if (constructing) {
          timerLine = `<div class="upReason">Under construction… <b>${fmtDuration(st.buildRemainingMs)}</b> left</div>`;
        } else if (upgrading) {
          timerLine = `<div class="upReason">Upgrading to <b>Lv ${st.upgradingToLevel || (lvl+1)}</b>… <b>${fmtDuration(st.upgradeRemainingMs)}</b> left</div>`;
        }

        buildGrid.innerHTML = `
          <div class="upCard">
            <div class="upTitle">${name}</div>
            <div class="upRow"><span>Current Level</span><b>${lvl}</b></div>
            <div class="upRow"><span>Cost</span><span class="upCost">${fmtCostPretty(upgradeCost)}</span></div>

            <button class="upBtn" type="button" data-action="build-upgrade" ${disabled ? "disabled" : ""}>
              ${upgrading ? "Upgrading…" : `Upgrade → Lv ${lvl + 1}`}
            </button>

            ${timerLine}
            ${(!constructing && !upgrading && !chk.ok) ? `<div class="upReason">${chk.reason}</div>` : ""}
            ${(!constructing && !upgrading && chk.ok && upgradeCost && !affordable) ? `<div class="upReason">Not enough resources</div>` : ""}
          </div>
        `;
      } else {
        buildTitle.textContent = `Plot: ${plot.id} (Build)`;
        const q = buildings.getQueueInfoSafe?.() || { full:false, max:2 };
        const queueBlocked = state.settings.timersEnabled && q.full;

        const frag = document.createDocumentFragment();

        for (const bKey of Object.keys(BUILDINGS).filter(k => k !== "townhall")) {
          const def = BUILDINGS[bKey];
          const cost = def?.cost || null;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "buildBtn";
          btn.setAttribute("data-action", "build-place");
          btn.setAttribute("data-building-id", bKey);
          btn.textContent = `${def?.name || bKey}${cost ? `\n${fmtCost(cost)}` : ""}`;

          const gate = canBuildBuildingCompat(bKey);
          if (!gate.ok) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = gate.reason;
          } else if (cost && !canAfford(cost)) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = "Not enough resources";
          }
          if (queueBlocked) {
            btn.disabled = true;
            btn.style.opacity = "0.35";
            btn.title = `All ${q.max} builder queues are busy.`;
}

          frag.appendChild(btn);
        }

        buildGrid.appendChild(frag);
      }

      popup.style.display = "block";
      if (recenter) centerPanelOnScreen(popup);
    }

    // Barracks panel (unchanged below)
    function fmtMMSS(ms) {
      const total = Math.max(0, Math.ceil(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function unlockedTiersForBarracksLevel(lvl) {
      const tiers = [];
      for (const tier of ["T1","T2","T3","T4"]) {
        if ((BARRACKS_TIER_UNLOCK?.[tier] ?? 999) <= lvl) tiers.push(tier);
      }
      return tiers;
    }

    function troopOptionsForBarracksLevel(barracksLevel) {
      const allowed = new Set(unlockedTiersForBarracksLevel(barracksLevel));
      return Object.values(TROOPS)
        .filter(t => allowed.has(t.tier))
        .map(t => ({ id: t.id, label: t.label ?? t.id }));
    }

    function getBarracksLevelSafe() {
      return Number(state?.buildings?.levels?.barracks || 0);
    }

    function findBarracksPlot(){
      return CITY_PLOTS.find(p => buildings.getPlacedOnPlot?.(p.id)?.buildingId === "barracks") || null;
    }

    function normalizeSlots(snap){
      let slots = snap?.slots ?? snap?.items ?? snap?.queue ?? snap?.queues?.barracks ?? snap?.queues;
      if (!Array.isArray(slots)) slots = slots ? Object.values(slots).flat() : [];
      return slots.map((s) => {
        if (s?.active) {
          const job = s.active;
          const now = Date.now();
          const totalMs = job.totalMs ?? Math.max(1, (job.endAt ?? now) - (job.startAt ?? now));
          const remainingMs = Math.max(0, (job.endAt ?? now) - now);
          return { status:"training", troopId:job.troopId, amount:job.amount, totalMs, remainingMs };
        }
        if (s?.status) return s;
        return { status:"idle" };
      });
    }

    function renderBarracksPanel({ recenter=true } = {}){
      const barracksLevel = getBarracksLevelSafe();
      try { syncBarracksSlots?.(barracksLevel); } catch {}

      const snap = getTrainingSnapshot?.("barracks") ?? {};
      const normalized = normalizeSlots(snap);
      const opts = troopOptionsForBarracksLevel(barracksLevel);

      const trainHtml = normalized.map((s, i) => {
        const isIdle = s.status === "idle" || !s.troopId;
        if (isIdle) {
          const options = opts.map(o => `<option value="${o.id}">${o.label}</option>`).join("");
          return `
            <div style="border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:12px;margin:10px 0;">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <b>Slot ${i+1}</b>
                <span style="opacity:.7">Idle</span>
              </div>

              <div style="display:flex;gap:8px;margin-top:10px;">
                <select data-slot="${i}" data-role="troop"
                  style="flex:1; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.12);
                  border-radius:12px; padding:10px;">
                  ${options || `<option value="">(No troops unlocked)</option>`}
                </select>

                <input data-slot="${i}" data-role="amt" type="number" min="1" value="1"
                  style="width:92px; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.12);
                  border-radius:12px; padding:10px;" />
              </div>

              <button type="button" data-action="bx-start" data-slot="${i}"
                style="margin-top:10px; width:100%; background:#2563eb; color:white; border:0;
                border-radius:12px; padding:12px; font-weight:900; cursor:pointer; touch-action:manipulation;">
                Train
              </button>
            </div>
          `;
        }

        const pct = s.totalMs ? Math.min(100, Math.max(0, 100 * (1 - s.remainingMs / s.totalMs))) : 0;
        return `
          <div style="border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:12px;margin:10px 0;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <b>Slot ${i+1}</b>
              <span style="opacity:.9">${s.troopId} × ${s.amount}</span>
            </div>

            <div style="margin-top:10px; height:10px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden;">
              <div style="height:100%; width:${pct}%; background:rgba(37,99,235,.95);"></div>
            </div>

            <div style="display:flex; justify-content:space-between; margin-top:8px; opacity:.85;">
              <span>${fmtMMSS(s.remainingMs)} left</span>
              <span>${Math.round(pct)}%</span>
            </div>

            <button type="button" data-action="bx-cancel" data-slot="${i}"
              style="margin-top:10px; width:100%; background:rgba(239,68,68,.95); color:white; border:0;
              border-radius:12px; padding:12px; font-weight:900; cursor:pointer; touch-action:manipulation;">
              Cancel
            </button>
          </div>
        `;
      }).join("");

      const barracksPlot = findBarracksPlot();
      const barracksPlaced = barracksPlot ? buildings.getPlacedOnPlot?.(barracksPlot.id) : null;

      let upgradeBlock = `<div style="opacity:.85">No barracks placed yet.</div>`;
      if (barracksPlaced && barracksPlot) {
        const lvl = barracksPlaced.level ?? 1;
        const chk = canUpgradePlotCompat(barracksPlot.id);
        const def = BUILDINGS?.barracks;
        const upgradeCost = def?.upgradeCost ? def.upgradeCost(lvl) : null;
        const affordable = canAfford(upgradeCost);

        const st = getStatusCompat(barracksPlot.id);
        const upgrading = !!st?.upgrading;
        const constructing = !!st?.constructing;

        const disabled = constructing || upgrading || (!chk.ok || (upgradeCost && !affordable) || !upgradeCost);

        let timerLine = "";
        if (constructing) timerLine = `<div class="upReason">Under construction… <b>${fmtDuration(st.buildRemainingMs)}</b> left</div>`;
        if (upgrading) timerLine = `<div class="upReason">Upgrading… <b>${fmtDuration(st.upgradeRemainingMs)}</b> left</div>`;

        upgradeBlock = `
          <div class="upCard">
            <div class="upTitle">Barracks</div>
            <div class="upRow"><span>Current Level:</span> <b>${lvl}</b></div>
            <div class="upRow"><span>Cost:</span> <span class="upCost">${fmtCostPretty(upgradeCost)}</span></div>

            <button type="button" class="upBtn" data-action="bx-upgrade" ${disabled ? "disabled" : ""}>
              ${upgrading ? "Upgrading…" : `Upgrade → Lv ${lvl+1}`}
            </button>

            ${timerLine}
            ${(!constructing && !upgrading && queueBlocked) ? `<div class="upReason">All ${q.max} builder queues are busy.</div>` : ""}

            ${(!constructing && !upgrading && !chk.ok ? `<div class="upReason">${chk.reason}</div>` : "")}
            ${(!constructing && !upgrading && chk.ok && upgradeCost && !affordable ? `<div class="upReason">Not enough resources</div>` : "")}

            <div class="upHint">Tiers unlock: L1=T1, L5=T2, L10=T3, L15=T4</div>
          </div>
        `;
      }

      barracksPanel.innerHTML = `
        <div class="bxHeader">
          <div>
            <div style="font-size:14px;font-weight:900;">Barracks</div>
            <div style="opacity:.7;margin-top:2px;">L${barracksLevel}</div>
          </div>
          <button class="bxClose" type="button" data-action="bx-close">Close</button>
        </div>

        <div class="bxWrap">
          <div class="bxTabs">
            <button class="bxTab ${barracksTab==="train"?"active":""}" data-action="bx-tab" data-tab="train" type="button">Train</button>
            <button class="bxTab ${barracksTab==="upgrade"?"active":""}" data-action="bx-tab" data-tab="upgrade" type="button">Upgrade</button>
          </div>

          <div class="bxMain">
            <div style="display:${barracksTab==="train"?"block":"none"};">
              ${trainHtml || `<div style="opacity:.8">No slots found.</div>`}
              <div class="upHint">Tiers unlock: L1=T1, L5=T2, L10=T3, L15=T4</div>
            </div>

            <div style="display:${barracksTab==="upgrade"?"block":"none"};">
              ${upgradeBlock}
            </div>
          </div>
        </div>
      `;

      if (recenter) centerPanelOnScreen(barracksPanel);
    }

    async function handleUiAction(action, el){
      if (action === "open-settings") {
        popup.style.display = "none";
        barracksPanel.style.display = "none";
        settingsPanel.style.display = "block";
        syncSettingsUI();
        centerPanelOnScreen(settingsPanel);
        return;
      }
      if (action === "settings-close") { settingsPanel.style.display = "none"; return; }
      if (action === "timers-finish-now") {
        buildings.finishAllTimersNow?.();
        if (popup.style.display !== "none" && currentBuildPlot) renderBuildPopupForPlot(currentBuildPlot, { recenter:false });
        if (barracksPanel.style.display !== "none") renderBarracksPanel({ recenter:false });
        try { saveGame(); } catch {}
        return;
      }
      if (action === "build-close") { popup.style.display = "none"; return; }

      if (action === "build-upgrade") {
        const plot = currentBuildPlot;
        if (!plot) return;
        const st = getStatusCompat(plot.id);
        if (st?.constructing || st?.upgrading) return;

        const res = await upgradePlotCompat(plot.id);
        if (!res?.ok) { alert(res?.reason || "Upgrade failed"); return; }

        syncLevelsFromPlaced();
        renderBuildPopupForPlot(plot, { recenter:false });
        try { saveGame(); } catch {}
        return;
      }

      if (action === "build-place") {
        const plot = currentBuildPlot;
        if (!plot) return;
        const bKey = el.getAttribute("data-building-id");
        if (!bKey) return;

        const r = await placeBuildingCompat(plot.id, bKey);
        if (r && r.ok === false) alert(r.reason || "Could not build.");

        syncLevelsFromPlaced();
        popup.style.display = "none";
        try { saveGame(); } catch {}
        return;
      }

      if (action === "bx-close") { barracksPanel.style.display = "none"; return; }
      if (action === "bx-tab") {
        barracksTab = el.getAttribute("data-tab") || "train";
        renderBarracksPanel({ recenter:true });
        return;
      }

      if (action === "bx-start") {
        const barracksLevel = getBarracksLevelSafe();
        const slotIndex = Number(el.getAttribute("data-slot"));
        const troopSel = barracksPanel.querySelector(`select[data-slot="${slotIndex}"][data-role="troop"]`);
        const amtInp  = barracksPanel.querySelector(`input[data-slot="${slotIndex}"][data-role="amt"]`);
        const troopId = troopSel?.value;
        const amount = Math.max(1, Number(amtInp?.value || 1));
        if (!troopId) return alert("No troop selected / unlocked.");
        const res = startTrainingInSlot({ barracksLevel, slotIndex, troopId, amount });
        if (!res?.ok) alert(res?.reason || "Could not start training.");
        renderBarracksPanel({ recenter:false });
        return;
      }

      if (action === "bx-cancel") {
        const slotIndex = Number(el.getAttribute("data-slot"));
        if (!confirm("Cancel this training slot?")) return;
        const res = cancelTraining?.({ slotIndex, refundPercent: 0.5 });
        if (res && res.ok === false) alert(res.reason || "Could not cancel.");
        renderBarracksPanel({ recenter:false });
        return;
      }

      if (action === "bx-upgrade") {
        const barracksPlot = findBarracksPlot();
        if (!barracksPlot) return;

        const st = getStatusCompat(barracksPlot.id);
        if (st?.constructing || st?.upgrading) return;

        const r = await upgradePlotCompat(barracksPlot.id);
        if (r && r.ok === false) { alert(r.reason || "Upgrade failed."); return; }

        syncLevelsFromPlaced();
        renderBarracksPanel({ recenter:false });
        try { saveGame(); } catch {}
        return;
      }
    }

    scene.setOnPlotClick((plot) => {
      if (!plot) return;
      if (uiJustHappened()) return;
      if (settingsPanel.style.display !== "none") return;

      const existing = buildings.getPlacedOnPlot?.(plot.id);
      const isBarracks = existing?.buildingId === "barracks";

      if (isBarracks) {
        popup.style.display = "none";
        settingsPanel.style.display = "none";
        barracksTab = "train";
        barracksPanel.style.display = "block";
        renderBarracksPanel({ recenter:true });
        return;
      }

      barracksPanel.style.display = "none";
      settingsPanel.style.display = "none";
      renderBuildPopupForPlot(plot, { recenter:true });
    });

    const fmt = (n) => Math.floor(n || 0).toLocaleString();
    const fmtRate = (n) => (Math.round((n || 0) * 10) / 10).toLocaleString();

    function renderResourceBar(){
      const p = getProductionPerSecond();
      resourceLeft.innerHTML = `
        <div class="resItem"><b>Food</b> ${fmt(state.resources.food)} <span>(+${fmtRate(p.food)}/s)</span></div>
        <div class="resItem"><b>Wood</b> ${fmt(state.resources.wood)} <span>(+${fmtRate(p.wood)}/s)</span></div>
        <div class="resItem"><b>Stone</b> ${fmt(state.resources.stone)} <span>(+${fmtRate(p.stone)}/s)</span></div>
        <div class="resItem"><b>Ore</b> ${fmt(state.resources.ore)} <span>(+${fmtRate(p.ore)}/s)</span></div>
        <div class="resItem"><b>Gold</b> ${fmt(state.resources.gold)} <span>(+${fmtRate(p.gold)}/s)</span></div>
        <div class="resItem" style="opacity:.9"><b>TH</b> ${state.buildings?.levels?.townhall || 0}</div>
        <div class="resItem" style="opacity:.85"><b>Timers</b> ${state.settings.timersEnabled ? "ON" : "OFF"}</div>
      `;
    }

    let econLast = 0;
    function economyFrame(t){
      const dt = econLast ? (t - econLast) / 1000 : 0;
      econLast = t;
      updateEconomy(dt);
      renderResourceBar();
      requestAnimationFrame(economyFrame);
    }
    requestAnimationFrame(economyFrame);

    function buildSavePayload() {
      syncLevelsFromPlaced();
      const placed = [];

      for (const plot of CITY_PLOTS) {
        const p = buildings.getPlacedOnPlot?.(plot.id);
        if (!p) continue;
        placed.push({
          plotId: plot.id,
          buildingId: p.buildingId,
          level: p.level ?? 1,
          buildStartedAt: p.buildStartedAt ?? 0,
          buildEndAt: p.buildEndAt ?? 0,
          upgradeStartedAt: p.upgradeStartedAt ?? 0,
          upgradeEndAt: p.upgradeEndAt ?? 0,
          upgradingToLevel: p.upgradingToLevel ?? 0,
        });
      }

      return {
        v: 1,
        ts: Date.now(),
        resources: { ...state.resources },
        levels: { ...state.buildings.levels },
        settings: { ...state.settings },
        placed,
      };
    }

    function saveGame() {
      const payload = buildSavePayload();
      const json = JSON.stringify(payload);
      localStorage.setItem(SAVE_KEY, json);

      const btn = document.getElementById("btnSave");
      if (btn) {
        const prev = btn.textContent;
        btn.textContent = "Saved ✓";
        setTimeout(() => (btn.textContent = prev), 900);
      }
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return console.warn("No save found.");
      sessionStorage.setItem(PENDING_KEY, raw);
      location.reload();
    }

    function resetSave() {
      localStorage.removeItem(SAVE_KEY);
      sessionStorage.removeItem(PENDING_KEY);
      location.reload();
    }

    async function applyPayload(data) {
      if (!data || typeof data !== "object") return false;

      if (data.resources) {
        state.resources.food  = Number(data.resources.food  ?? 0);
        state.resources.wood  = Number(data.resources.wood  ?? 0);
        state.resources.stone = Number(data.resources.stone ?? 0);
        state.resources.ore   = Number(data.resources.ore   ?? 0);
        state.resources.gold  = Number(data.resources.gold  ?? 0);
      }

      if (data.settings && typeof data.settings === "object") {
        state.settings.timersEnabled = (typeof data.settings.timersEnabled === "boolean")
          ? data.settings.timersEnabled
          : state.settings.timersEnabled;
        syncSettingsUI();
      }

      if (Array.isArray(data.placed)) {
        await buildings.hydrateFromSave?.(data.placed);
      } else {
        buildings.resetAllPlaced?.();
      }

      await buildings.ensureTownhall?.();
      syncLevelsFromPlaced();
      return true;
    }

    (async function bootLoad() {
      const pending = sessionStorage.getItem(PENDING_KEY);
      if (!pending) {
        await buildings.ensureTownhall?.();
        syncLevelsFromPlaced();
        return;
      }

      sessionStorage.removeItem(PENDING_KEY);
      try {
        const data = JSON.parse(pending);
        await applyPayload(data);
      } catch (e) {
        console.error("Pending load failed:", e);
        await buildings.ensureTownhall?.();
        syncLevelsFromPlaced();
      }
    })();

    document.getElementById("btnSave").onclick = saveGame;
    document.getElementById("btnLoad").onclick = loadGame;
    document.getElementById("btnReset").onclick = resetSave;
    setInterval(() => { try { saveGame(); } catch {} }, 10000);

    setInterval(() => {
      if (barracksPanel.style.display === "none") return;
      const snap = getTrainingSnapshot?.("barracks") ?? {};
      const slots = normalizeSlots(snap);
      if (!slots.some(s => s.status === "training")) return;
      requestAnimationFrame(() => renderBarracksPanel({ recenter:false }));
    }, 250);

    let lastTimersTick = 0;
    function timersFrame(){
      const now = performance.now();
      if (now - lastTimersTick < 250) return;
      lastTimersTick = now;

      const changed = buildings.tick?.() || false;

      if (popup.style.display !== "none" && currentBuildPlot) renderBuildPopupForPlot(currentBuildPlot, { recenter:false });
      if (barracksPanel.style.display !== "none") renderBarracksPanel({ recenter:false });

      if (changed) {
        syncLevelsFromPlaced();
        try { saveGame(); } catch {}
      }
    }

  window.addEventListener("resize", () => {
  updateUiOverlayRect();
  if (isPanelVisible(popup)) centerPanelOnScreen(popup);
  if (isPanelVisible(barracksPanel)) centerPanelOnScreen(barracksPanel);
  if (isPanelVisible(settingsPanel)) centerPanelOnScreen(settingsPanel);
});



    function frame(){
      scene.update();
      scene.render();

      processTrainingQueues();
      updateUiOverlayRect();
      timersFrame();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
</body>
</html>
